{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.MessageFormat = factory());\n})(this, function () {\n  'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n      writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    return _construct.apply(null, arguments);\n  }\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n  }\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    } else if (call !== void 0) {\n      throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n  }\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf(Derived),\n        result;\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n  function _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n  }\n  function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n  function _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n  function _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        var F = function () {};\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true,\n      didErr = false,\n      err;\n    return {\n      s: function () {\n        it = it.call(o);\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n  var _assign = function __assign() {\n    _assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) {\n          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n      }\n      return t;\n    };\n    return _assign.apply(this, arguments);\n  };\n  function __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n      next: function next() {\n        if (o && i >= o.length) o = void 0;\n        return {\n          value: o && o[i++],\n          done: !o\n        };\n      }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  }\n  function __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o),\n      r,\n      ar = [],\n      e;\n    try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n        ar.push(r.value);\n      }\n    } catch (error) {\n      e = {\n        error: error\n      };\n    } finally {\n      try {\n        if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      } finally {\n        if (e) throw e.error;\n      }\n    }\n    return ar;\n  }\n  function __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n        if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n        ar[i] = from[i];\n      }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n  }\n\n  /**\n   * Parent class for errors.\n   *\n   * @remarks\n   * Errors with `type: \"warning\"` do not necessarily indicate that the parser\n   * encountered an error. In addition to a human-friendly `message`, may also\n   * includes the `token` at which the error was encountered.\n   *\n   * @public\n   */\n  var DateFormatError = /*#__PURE__*/function (_Error) {\n    _inherits(DateFormatError, _Error);\n    var _super = _createSuper(DateFormatError);\n\n    /** @internal */\n    function DateFormatError(msg, token, type) {\n      var _this;\n      _classCallCheck(this, DateFormatError);\n      _this = _super.call(this, msg);\n      _this.token = token;\n      _this.type = type || 'error';\n      return _this;\n    }\n    return _createClass(DateFormatError);\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n  var alpha = function alpha(width) {\n    return width < 4 ? 'short' : width === 4 ? 'long' : 'narrow';\n  };\n  var numeric = function numeric(width) {\n    return width % 2 === 0 ? '2-digit' : 'numeric';\n  };\n  function yearOptions(token, onError) {\n    switch (token.char) {\n      case 'y':\n        return {\n          year: numeric(token.width)\n        };\n      case 'r':\n        return {\n          calendar: 'gregory',\n          year: 'numeric'\n        };\n      case 'u':\n      case 'U':\n      case 'Y':\n      default:\n        onError(\"\".concat(token.desc, \" is not supported; falling back to year:numeric\"), DateFormatError.WARNING);\n        return {\n          year: 'numeric'\n        };\n    }\n  }\n  function monthStyle(token, onError) {\n    switch (token.width) {\n      case 1:\n        return 'numeric';\n      case 2:\n        return '2-digit';\n      case 3:\n        return 'short';\n      case 4:\n        return 'long';\n      case 5:\n        return 'narrow';\n      default:\n        onError(\"\".concat(token.desc, \" is not supported with width \").concat(token.width));\n        return undefined;\n    }\n  }\n  function dayStyle(token, onError) {\n    var char = token.char,\n      desc = token.desc,\n      width = token.width;\n    if (char === 'd') return numeric(width);else {\n      onError(\"\".concat(desc, \" is not supported\"));\n      return undefined;\n    }\n  }\n  function weekdayStyle(token, onError) {\n    var char = token.char,\n      desc = token.desc,\n      width = token.width;\n    if ((char === 'c' || char === 'e') && width < 3) {\n      // ignoring stand-alone-ness\n      var msg = \"Numeric value is not supported for \".concat(desc, \"; falling back to weekday:short\");\n      onError(msg, DateFormatError.WARNING);\n    } // merging narrow styles\n\n    return alpha(width);\n  }\n  function hourOptions(token) {\n    var hour = numeric(token.width);\n    var hourCycle;\n    switch (token.char) {\n      case 'h':\n        hourCycle = 'h12';\n        break;\n      case 'H':\n        hourCycle = 'h23';\n        break;\n      case 'k':\n        hourCycle = 'h24';\n        break;\n      case 'K':\n        hourCycle = 'h11';\n        break;\n    }\n    return hourCycle ? {\n      hour: hour,\n      hourCycle: hourCycle\n    } : {\n      hour: hour\n    };\n  }\n  function timeZoneNameStyle(token, onError) {\n    // so much fallback behaviour here\n    var char = token.char,\n      desc = token.desc,\n      width = token.width;\n    switch (char) {\n      case 'v':\n      case 'z':\n        return width === 4 ? 'long' : 'short';\n      case 'V':\n        if (width === 4) return 'long';\n        onError(\"\".concat(desc, \" is not supported with width \").concat(width));\n        return undefined;\n      case 'X':\n        onError(\"\".concat(desc, \" is not supported\"));\n        return undefined;\n    }\n    return 'short';\n  }\n  function compileOptions(token, onError) {\n    switch (token.field) {\n      case 'era':\n        return {\n          era: alpha(token.width)\n        };\n      case 'year':\n        return yearOptions(token, onError);\n      case 'month':\n        return {\n          month: monthStyle(token, onError)\n        };\n      case 'day':\n        return {\n          day: dayStyle(token, onError)\n        };\n      case 'weekday':\n        return {\n          weekday: weekdayStyle(token, onError)\n        };\n      case 'period':\n        return undefined;\n      case 'hour':\n        return hourOptions(token);\n      case 'min':\n        return {\n          minute: numeric(token.width)\n        };\n      case 'sec':\n        return {\n          second: numeric(token.width)\n        };\n      case 'tz':\n        return {\n          timeZoneName: timeZoneNameStyle(token, onError)\n        };\n      case 'quarter':\n      case 'week':\n      case 'sec-frac':\n      case 'ms':\n        onError(\"\".concat(token.desc, \" is not supported\"));\n    }\n    return undefined;\n  }\n  function getDateFormatOptions(tokens) {\n    var onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (error) {\n      throw error;\n    };\n    var options = {};\n    var fields = [];\n    var _iterator = _createForOfIteratorHelper(tokens),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var token = _step.value;\n        var error = token.error,\n          field = token.field,\n          str = token.str;\n        if (error) {\n          var dte = new DateFormatError(error.message, token);\n          dte.stack = error.stack;\n          onError(dte);\n        }\n        if (str) {\n          var msg = \"Ignoring string part: \".concat(str);\n          onError(new DateFormatError(msg, token, DateFormatError.WARNING));\n        }\n        if (field) {\n          if (fields.indexOf(field) === -1) fields.push(field);else onError(new DateFormatError(\"Duplicate \".concat(field, \" token\"), token));\n        }\n        var opt = compileOptions(token, function (msg, isWarning) {\n          return onError(new DateFormatError(msg, token, isWarning));\n        });\n        if (opt) Object.assign(options, opt);\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return options;\n  }\n  var fields = {\n    G: {\n      field: 'era',\n      desc: 'Era'\n    },\n    y: {\n      field: 'year',\n      desc: 'Year'\n    },\n    Y: {\n      field: 'year',\n      desc: 'Year of \"Week of Year\"'\n    },\n    u: {\n      field: 'year',\n      desc: 'Extended year'\n    },\n    U: {\n      field: 'year',\n      desc: 'Cyclic year name'\n    },\n    r: {\n      field: 'year',\n      desc: 'Related Gregorian year'\n    },\n    Q: {\n      field: 'quarter',\n      desc: 'Quarter'\n    },\n    q: {\n      field: 'quarter',\n      desc: 'Stand-alone quarter'\n    },\n    M: {\n      field: 'month',\n      desc: 'Month in year'\n    },\n    L: {\n      field: 'month',\n      desc: 'Stand-alone month in year'\n    },\n    w: {\n      field: 'week',\n      desc: 'Week of year'\n    },\n    W: {\n      field: 'week',\n      desc: 'Week of month'\n    },\n    d: {\n      field: 'day',\n      desc: 'Day in month'\n    },\n    D: {\n      field: 'day',\n      desc: 'Day of year'\n    },\n    F: {\n      field: 'day',\n      desc: 'Day of week in month'\n    },\n    g: {\n      field: 'day',\n      desc: 'Modified julian day'\n    },\n    E: {\n      field: 'weekday',\n      desc: 'Day of week'\n    },\n    e: {\n      field: 'weekday',\n      desc: 'Local day of week'\n    },\n    c: {\n      field: 'weekday',\n      desc: 'Stand-alone local day of week'\n    },\n    a: {\n      field: 'period',\n      desc: 'AM/PM marker'\n    },\n    b: {\n      field: 'period',\n      desc: 'AM/PM/noon/midnight marker'\n    },\n    B: {\n      field: 'period',\n      desc: 'Flexible day period'\n    },\n    h: {\n      field: 'hour',\n      desc: 'Hour in AM/PM (1~12)'\n    },\n    H: {\n      field: 'hour',\n      desc: 'Hour in day (0~23)'\n    },\n    k: {\n      field: 'hour',\n      desc: 'Hour in day (1~24)'\n    },\n    K: {\n      field: 'hour',\n      desc: 'Hour in AM/PM (0~11)'\n    },\n    j: {\n      field: 'hour',\n      desc: 'Hour in preferred cycle'\n    },\n    J: {\n      field: 'hour',\n      desc: 'Hour in preferred cycle without marker'\n    },\n    C: {\n      field: 'hour',\n      desc: 'Hour in preferred cycle with flexible marker'\n    },\n    m: {\n      field: 'min',\n      desc: 'Minute in hour'\n    },\n    s: {\n      field: 'sec',\n      desc: 'Second in minute'\n    },\n    S: {\n      field: 'sec-frac',\n      desc: 'Fractional second'\n    },\n    A: {\n      field: 'ms',\n      desc: 'Milliseconds in day'\n    },\n    z: {\n      field: 'tz',\n      desc: 'Time Zone: specific non-location'\n    },\n    Z: {\n      field: 'tz',\n      desc: 'Time Zone'\n    },\n    O: {\n      field: 'tz',\n      desc: 'Time Zone: localized'\n    },\n    v: {\n      field: 'tz',\n      desc: 'Time Zone: generic non-location'\n    },\n    V: {\n      field: 'tz',\n      desc: 'Time Zone: ID'\n    },\n    X: {\n      field: 'tz',\n      desc: 'Time Zone: ISO8601 with Z'\n    },\n    x: {\n      field: 'tz',\n      desc: 'Time Zone: ISO8601'\n    }\n  };\n  var isLetter = function isLetter(char) {\n    return char >= 'A' && char <= 'Z' || char >= 'a' && char <= 'z';\n  };\n  function readFieldToken(src, pos) {\n    var char = src[pos];\n    var width = 1;\n    while (src[++pos] === char) {\n      ++width;\n    }\n    var field = fields[char];\n    if (!field) {\n      var msg = \"The letter \".concat(char, \" is not a valid field identifier\");\n      return {\n        char: char,\n        error: new Error(msg),\n        width: width\n      };\n    }\n    return {\n      char: char,\n      field: field.field,\n      desc: field.desc,\n      width: width\n    };\n  }\n  function readQuotedToken(src, pos) {\n    var str = src[++pos];\n    var width = 2;\n    if (str === \"'\") return {\n      char: \"'\",\n      str: str,\n      width: width\n    };\n    while (true) {\n      var next = src[++pos];\n      ++width;\n      if (next === undefined) {\n        var msg = \"Unterminated quoted literal in pattern: \".concat(str || src);\n        return {\n          char: \"'\",\n          error: new Error(msg),\n          str: str,\n          width: width\n        };\n      } else if (next === \"'\") {\n        if (src[++pos] !== \"'\") return {\n          char: \"'\",\n          str: str,\n          width: width\n        };else ++width;\n      }\n      str += next;\n    }\n  }\n  function readToken(src, pos) {\n    var char = src[pos];\n    if (!char) return null;\n    if (isLetter(char)) return readFieldToken(src, pos);\n    if (char === \"'\") return readQuotedToken(src, pos);\n    var str = char;\n    var width = 1;\n    while (true) {\n      var next = src[++pos];\n      if (!next || isLetter(next) || next === \"'\") return {\n        char: char,\n        str: str,\n        width: width\n      };\n      str += next;\n      width += 1;\n    }\n  }\n  /**\n   * Parse an {@link http://userguide.icu-project.org/formatparse/datetime | ICU\n   * DateFormat skeleton} string into a {@link DateToken} array.\n   *\n   * @remarks\n   * Errors will not be thrown, but if encountered are included as the relevant\n   * token's `error` value.\n   *\n   * @public\n   * @param src - The skeleton string\n   *\n   * @example\n   * ```js\n   * import { parseDateTokens } from '@messageformat/date-skeleton'\n   *\n   * parseDateTokens('GrMMMdd', console.error)\n   * // [\n   * //   { char: 'G', field: 'era', desc: 'Era', width: 1 },\n   * //   { char: 'r', field: 'year', desc: 'Related Gregorian year', width: 1 },\n   * //   { char: 'M', field: 'month', desc: 'Month in year', width: 3 },\n   * //   { char: 'd', field: 'day', desc: 'Day in month', width: 2 }\n   * // ]\n   * ```\n   */\n\n  function parseDateTokens(src) {\n    var tokens = [];\n    var pos = 0;\n    while (true) {\n      var token = readToken(src, pos);\n      if (!token) return tokens;\n      tokens.push(token);\n      pos += token.width;\n    }\n  }\n\n  /**\n   * Returns a date formatter function for the given locales and date skeleton\n   *\n   * @remarks\n   * Uses `Intl.DateTimeFormat` internally.\n   *\n   * @public\n   * @param locales - One or more valid BCP 47 language tags, e.g. `fr` or `en-CA`\n   * @param tokens - An ICU DateFormat skeleton string, or an array or parsed\n   *   `DateToken` tokens\n   * @param onError - If defined, will be called separately for each encountered\n   *   parsing error and unsupported feature.\n   * @example\n   * ```js\n   * import { getDateFormatter } from '@messageformat/date-skeleton'\n   *\n   * // 2006 Jan 2, 15:04:05.789 in local time\n   * const date = new Date(2006, 0, 2, 15, 4, 5, 789)\n   *\n   * let fmt = getDateFormatter('en-CA', 'GrMMMdd', console.error)\n   * fmt(date) // 'Jan. 02, 2006 AD'\n   *\n   * fmt = getDateFormatter('en-CA', 'hamszzzz', console.error)\n   * fmt(date) // '3:04:05 p.m. Newfoundland Daylight Time'\n   * ```\n   */\n\n  function getDateFormatter(locales, tokens, onError) {\n    if (typeof tokens === 'string') tokens = parseDateTokens(tokens);\n    var opt = getDateFormatOptions(tokens, onError);\n    var dtf = new Intl.DateTimeFormat(locales, opt);\n    return function (date) {\n      return dtf.format(date);\n    };\n  }\n  /**\n   * Returns a string of JavaScript source that evaluates to a date formatter\n   * function with the same `(date: Date | number) => string` signature as the\n   * function returned by {@link getDateFormatter}.\n   *\n   * @remarks\n   * The returned function will memoize an `Intl.DateTimeFormat` instance.\n   *\n   * @public\n   * @param locales - One or more valid BCP 47 language tags, e.g. `fr` or `en-CA`\n   * @param tokens - An ICU DateFormat skeleton string, or an array or parsed\n   *   `DateToken` tokens\n   * @param onError - If defined, will be called separately for each encountered\n   *   parsing error and unsupported feature.\n   * @example\n   * ```js\n   * import { getDateFormatterSource } from '@messageformat/date-skeleton'\n   *\n   * getDateFormatterSource('en-CA', 'GrMMMdd', console.error)\n   * // '(function() {\\n' +\n   * // '  var opt = {\"era\":\"short\",\"calendar\":\"gregory\",\"year\":\"numeric\",' +\n   * //      '\"month\":\"short\",\"day\":\"2-digit\"};\\n' +\n   * // '  var dtf = new Intl.DateTimeFormat(\"en-CA\", opt);\\n' +\n   * // '  return function(value) { return dtf.format(value); }\\n' +\n   * // '})()'\n   *\n   * const src = getDateFormatterSource('en-CA', 'hamszzzz', console.error)\n   * // '(function() {\\n' +\n   * // '  var opt = {\"hour\":\"numeric\",\"hourCycle\":\"h12\",\"minute\":\"numeric\",' +\n   * //      '\"second\":\"numeric\",\"timeZoneName\":\"long\"};\\n' +\n   * // '  var dtf = new Intl.DateTimeFormat(\"en-CA\", opt);\\n' +\n   * // '  return function(value) { return dtf.format(value); }\\n' +\n   * // '})()'\n   *\n   * const fmt = new Function(`return ${src}`)()\n   * const date = new Date(2006, 0, 2, 15, 4, 5, 789)\n   * fmt(date) // '3:04:05 p.m. Newfoundland Daylight Time'\n   * ```\n   */\n\n  function getDateFormatterSource(locales, tokens, onError) {\n    if (typeof tokens === 'string') tokens = parseDateTokens(tokens);\n    var opt = getDateFormatOptions(tokens, onError);\n    var lines = [\"(function() {\", \"var opt = \".concat(JSON.stringify(opt), \";\"), \"var dtf = new Intl.DateTimeFormat(\".concat(JSON.stringify(locales), \", opt);\"), \"return function(value) { return dtf.format(value); }\"];\n    return lines.join('\\n  ') + '\\n})()';\n  }\n\n  /**\n   * Base class for errors. In addition to a `code` and a human-friendly\n   * `message`, may also includes the token `stem` as well as other fields.\n   *\n   * @public\n   */\n  var NumberFormatError = /*#__PURE__*/function (_Error) {\n    _inherits(NumberFormatError, _Error);\n    var _super = _createSuper(NumberFormatError);\n\n    /** @internal */\n    function NumberFormatError(code, msg) {\n      var _this;\n      _classCallCheck(this, NumberFormatError);\n      _this = _super.call(this, msg);\n      _this.code = code;\n      return _this;\n    }\n    return _createClass(NumberFormatError);\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n  /** @internal */\n\n  var BadOptionError = /*#__PURE__*/function (_NumberFormatError) {\n    _inherits(BadOptionError, _NumberFormatError);\n    var _super2 = _createSuper(BadOptionError);\n    function BadOptionError(stem, opt) {\n      var _this2;\n      _classCallCheck(this, BadOptionError);\n      _this2 = _super2.call(this, 'BAD_OPTION', \"Unknown \".concat(stem, \" option: \").concat(opt));\n      _this2.stem = stem;\n      _this2.option = opt;\n      return _this2;\n    }\n    return _createClass(BadOptionError);\n  }(NumberFormatError);\n  /** @internal */\n\n  var BadStemError = /*#__PURE__*/function (_NumberFormatError2) {\n    _inherits(BadStemError, _NumberFormatError2);\n    var _super3 = _createSuper(BadStemError);\n    function BadStemError(stem) {\n      var _this3;\n      _classCallCheck(this, BadStemError);\n      _this3 = _super3.call(this, 'BAD_STEM', \"Unknown stem: \".concat(stem));\n      _this3.stem = stem;\n      return _this3;\n    }\n    return _createClass(BadStemError);\n  }(NumberFormatError);\n  /** @internal */\n\n  var MaskedValueError = /*#__PURE__*/function (_NumberFormatError3) {\n    _inherits(MaskedValueError, _NumberFormatError3);\n    var _super4 = _createSuper(MaskedValueError);\n    function MaskedValueError(type, prev) {\n      var _this4;\n      _classCallCheck(this, MaskedValueError);\n      _this4 = _super4.call(this, 'MASKED_VALUE', \"Value for \".concat(type, \" is set multiple times\"));\n      _this4.type = type;\n      _this4.prev = prev;\n      return _this4;\n    }\n    return _createClass(MaskedValueError);\n  }(NumberFormatError);\n  /** @internal */\n\n  var MissingOptionError = /*#__PURE__*/function (_NumberFormatError4) {\n    _inherits(MissingOptionError, _NumberFormatError4);\n    var _super5 = _createSuper(MissingOptionError);\n    function MissingOptionError(stem) {\n      var _this5;\n      _classCallCheck(this, MissingOptionError);\n      _this5 = _super5.call(this, 'MISSING_OPTION', \"Required option missing for \".concat(stem));\n      _this5.stem = stem;\n      return _this5;\n    }\n    return _createClass(MissingOptionError);\n  }(NumberFormatError);\n  /** @internal */\n\n  var PatternError = /*#__PURE__*/function (_NumberFormatError5) {\n    _inherits(PatternError, _NumberFormatError5);\n    var _super6 = _createSuper(PatternError);\n    function PatternError(char, msg) {\n      var _this6;\n      _classCallCheck(this, PatternError);\n      _this6 = _super6.call(this, 'BAD_PATTERN', msg);\n      _this6.char = char;\n      return _this6;\n    }\n    return _createClass(PatternError);\n  }(NumberFormatError);\n  /** @internal */\n\n  var TooManyOptionsError = /*#__PURE__*/function (_NumberFormatError6) {\n    _inherits(TooManyOptionsError, _NumberFormatError6);\n    var _super7 = _createSuper(TooManyOptionsError);\n    function TooManyOptionsError(stem, options, maxOpt) {\n      var _this7;\n      _classCallCheck(this, TooManyOptionsError);\n      var maxOptStr = maxOpt > 1 ? \"\".concat(maxOpt, \" options\") : 'one option';\n      _this7 = _super7.call(this, 'TOO_MANY_OPTIONS', \"Token \".concat(stem, \" only supports \").concat(maxOptStr, \" (got \").concat(options.length, \")\"));\n      _this7.stem = stem;\n      _this7.options = options;\n      return _this7;\n    }\n    return _createClass(TooManyOptionsError);\n  }(NumberFormatError);\n  /** @internal */\n\n  var UnsupportedError = /*#__PURE__*/function (_NumberFormatError7) {\n    _inherits(UnsupportedError, _NumberFormatError7);\n    var _super8 = _createSuper(UnsupportedError);\n    function UnsupportedError(stem, source) {\n      var _this8;\n      _classCallCheck(this, UnsupportedError);\n      _this8 = _super8.call(this, 'UNSUPPORTED', \"The stem \".concat(stem, \" is not supported\"));\n      _this8.stem = stem;\n      if (source) {\n        _this8.message += \" with value \".concat(source);\n        _this8.source = source;\n      }\n      return _this8;\n    }\n    return _createClass(UnsupportedError);\n  }(NumberFormatError);\n\n  /**\n   * Add\n   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl#Locale_identification_and_negotiation | numbering-system tags}\n   * to locale identifiers\n   *\n   * @internal\n   */\n  function getNumberFormatLocales(locales, _ref) {\n    var numberingSystem = _ref.numberingSystem;\n    if (!Array.isArray(locales)) locales = [locales];\n    return numberingSystem ? locales.map(function (lc) {\n      var ext = lc.indexOf('-u-') === -1 ? 'u-nu' : 'nu';\n      return \"\".concat(lc, \"-\").concat(ext, \"-\").concat(numberingSystem);\n    }).concat(locales) : locales;\n  }\n\n  // from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round\n  function round(x, precision) {\n    var y = +x + precision / 2;\n    return y - y % +precision;\n  }\n  function getNumberFormatMultiplier(_ref) {\n    var scale = _ref.scale,\n      unit = _ref.unit;\n    var mult = typeof scale === 'number' && scale >= 0 ? scale : 1;\n    if (unit && unit.style === 'percent') mult *= 0.01;\n    return mult;\n  }\n  /**\n   * Determine a modifier for the input value to account for any `scale`,\n   * `percent`, and `precision-increment` tokens in the skeleton.\n   *\n   * @internal\n   * @remarks\n   * With ICU NumberFormatter, the `percent` skeleton would style `25` as \"25%\".\n   * To achieve the same with `Intl.NumberFormat`, the input value must be `0.25`.\n   */\n\n  function getNumberFormatModifier(skeleton) {\n    var mult = getNumberFormatMultiplier(skeleton);\n    var precision = skeleton.precision;\n    if (precision && precision.style === 'precision-increment') {\n      return function (n) {\n        return round(n, precision.increment) * mult;\n      };\n    } else {\n      return function (n) {\n        return n * mult;\n      };\n    }\n  }\n  /**\n   * Returns a string of JavaScript source that evaluates to a modifier for the\n   * input value to account for any `scale`, `percent`, and `precision-increment`\n   * tokens in the skeleton.\n   *\n   * @internal\n   * @remarks\n   * With ICU NumberFormatter, the `percent` skeleton would style `25` as \"25%\".\n   * To achieve the same with `Intl.NumberFormat`, the input value must be `0.25`.\n   */\n\n  function getNumberFormatModifierSource(skeleton) {\n    var mult = getNumberFormatMultiplier(skeleton);\n    var precision = skeleton.precision;\n    if (precision && precision.style === 'precision-increment') {\n      // see round() above for source\n      var setX = \"+n + \".concat(precision.increment / 2);\n      var res = \"x - (x % +\".concat(precision.increment, \")\");\n      if (mult !== 1) res = \"(\".concat(res, \") * \").concat(mult);\n      return \"function(n) { var x = \".concat(setX, \"; return \").concat(res, \"; }\");\n    }\n    return mult !== 1 ? \"function(n) { return n * \".concat(mult, \"; }\") : null;\n  }\n\n  /**\n   * Given an input ICU NumberFormatter skeleton, does its best to construct a\n   * corresponding `Intl.NumberFormat` options structure.\n   *\n   * @remarks\n   * Some features depend on `Intl.NumberFormat` features defined in ES2020.\n   *\n   * @internal\n   * @param onUnsupported - If defined, called when encountering unsupported (but\n   *   valid) tokens, such as `decimal-always` or `permille`. The error `source`\n   *   may specify the source of an unsupported option.\n   *\n   * @example\n   * ```js\n   * import {\n   *   getNumberFormatOptions,\n   *   parseNumberSkeleton\n   * } from '@messageformat/number-skeleton'\n   *\n   * const src = 'currency/CAD unit-width-narrow'\n   * const skeleton = parseNumberSkeleton(src, console.error)\n   * // {\n   * //   unit: { style: 'currency', currency: 'CAD' },\n   * //   unitWidth: 'unit-width-narrow'\n   * // }\n   *\n   * getNumberFormatOptions(skeleton, console.error)\n   * // {\n   * //   style: 'currency',\n   * //   currency: 'CAD',\n   * //   currencyDisplay: 'narrowSymbol',\n   * //   unitDisplay: 'narrow'\n   * // }\n   *\n   * const sk2 = parseNumberSkeleton('group-min2')\n   * // { group: 'group-min2' }\n   *\n   * getNumberFormatOptions(sk2, console.error)\n   * // Error: The stem group-min2 is not supported\n   * //   at UnsupportedError.NumberFormatError ... {\n   * //     code: 'UNSUPPORTED',\n   * //     stem: 'group-min2'\n   * //   }\n   * // {}\n   * ```\n   */\n\n  function getNumberFormatOptions(skeleton, onUnsupported) {\n    var decimal = skeleton.decimal,\n      group = skeleton.group,\n      integerWidth = skeleton.integerWidth,\n      notation = skeleton.notation,\n      precision = skeleton.precision,\n      roundingMode = skeleton.roundingMode,\n      sign = skeleton.sign,\n      unit = skeleton.unit,\n      unitPer = skeleton.unitPer,\n      unitWidth = skeleton.unitWidth;\n    var fail = function fail(stem, source) {\n      if (onUnsupported) onUnsupported(new UnsupportedError(stem, source));\n    };\n    var opt = {};\n    if (unit) {\n      switch (unit.style) {\n        case 'base-unit':\n          opt.style = 'decimal';\n          break;\n        case 'currency':\n          opt.style = 'currency';\n          opt.currency = unit.currency;\n          break;\n        case 'measure-unit':\n          opt.style = 'unit';\n          opt.unit = unit.unit.replace(/.*-/, '');\n          if (unitPer) opt.unit += '-per-' + unitPer.replace(/.*-/, '');\n          break;\n        case 'percent':\n          opt.style = 'percent';\n          break;\n        case 'permille':\n          fail('permille');\n          break;\n      }\n    }\n    switch (unitWidth) {\n      case 'unit-width-full-name':\n        opt.currencyDisplay = 'name';\n        opt.unitDisplay = 'long';\n        break;\n      case 'unit-width-hidden':\n        fail(unitWidth);\n        break;\n      case 'unit-width-iso-code':\n        opt.currencyDisplay = 'code';\n        break;\n      case 'unit-width-narrow':\n        opt.currencyDisplay = 'narrowSymbol';\n        opt.unitDisplay = 'narrow';\n        break;\n      case 'unit-width-short':\n        opt.currencyDisplay = 'symbol';\n        opt.unitDisplay = 'short';\n        break;\n    }\n    switch (group) {\n      case 'group-off':\n        opt.useGrouping = false;\n        break;\n      case 'group-auto':\n        opt.useGrouping = true;\n        break;\n      case 'group-min2':\n      case 'group-on-aligned':\n      case 'group-thousands':\n        fail(group);\n        opt.useGrouping = true;\n        break;\n    }\n    if (precision) {\n      switch (precision.style) {\n        case 'precision-fraction':\n          {\n            var minF = precision.minFraction,\n              maxF = precision.maxFraction,\n              minS = precision.minSignificant,\n              maxS = precision.maxSignificant,\n              source = precision.source;\n            if (typeof minF === 'number') {\n              opt.minimumFractionDigits = minF;\n              if (typeof minS === 'number') fail('precision-fraction', source);\n            }\n            if (typeof maxF === 'number') opt.maximumFractionDigits = maxF;\n            if (typeof minS === 'number') opt.minimumSignificantDigits = minS;\n            if (typeof maxS === 'number') opt.maximumSignificantDigits = maxS;\n            break;\n          }\n        case 'precision-integer':\n          opt.maximumFractionDigits = 0;\n          break;\n        case 'precision-unlimited':\n          opt.maximumFractionDigits = 20;\n          break;\n        case 'precision-increment':\n        case 'precision-currency-standard':\n          break;\n        case 'precision-currency-cash':\n          fail(precision.style);\n          break;\n      }\n    }\n    if (notation) {\n      switch (notation.style) {\n        case 'compact-short':\n          opt.notation = 'compact';\n          opt.compactDisplay = 'short';\n          break;\n        case 'compact-long':\n          opt.notation = 'compact';\n          opt.compactDisplay = 'long';\n          break;\n        case 'notation-simple':\n          opt.notation = 'standard';\n          break;\n        case 'scientific':\n        case 'engineering':\n          {\n            var expDigits = notation.expDigits,\n              expSign = notation.expSign,\n              _source = notation.source,\n              style = notation.style;\n            opt.notation = style;\n            if (expDigits && expDigits > 1 || expSign && expSign !== 'sign-auto') fail(style, _source);\n            break;\n          }\n      }\n    }\n    if (integerWidth) {\n      var min = integerWidth.min,\n        max = integerWidth.max,\n        _source2 = integerWidth.source;\n      if (min > 0) opt.minimumIntegerDigits = min;\n      if (Number(max) > 0) {\n        var hasExp = opt.notation === 'engineering' || opt.notation === 'scientific';\n        if (max === 3 && hasExp) opt.notation = 'engineering';else fail('integer-width', _source2);\n      }\n    }\n    switch (sign) {\n      case 'sign-auto':\n        opt.signDisplay = 'auto';\n        break;\n      case 'sign-always':\n        opt.signDisplay = 'always';\n        break;\n      case 'sign-except-zero':\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/microsoft/TypeScript/issues/46712\n        opt.signDisplay = 'exceptZero';\n        break;\n      case 'sign-never':\n        opt.signDisplay = 'never';\n        break;\n      case 'sign-accounting':\n        opt.currencySign = 'accounting';\n        break;\n      case 'sign-accounting-always':\n        opt.currencySign = 'accounting';\n        opt.signDisplay = 'always';\n        break;\n      case 'sign-accounting-except-zero':\n        opt.currencySign = 'accounting'; // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/microsoft/TypeScript/issues/46712\n\n        opt.signDisplay = 'exceptZero';\n        break;\n    }\n    if (decimal === 'decimal-always') fail(decimal);\n    if (roundingMode) fail(roundingMode);\n    return opt;\n  }\n  function parseAffixToken(src, pos, onError) {\n    var char = src[pos];\n    switch (char) {\n      case '%':\n        return {\n          char: '%',\n          style: 'percent',\n          width: 1\n        };\n      case '‰':\n        return {\n          char: '%',\n          style: 'permille',\n          width: 1\n        };\n      case '¤':\n        {\n          var width = 1;\n          while (src[++pos] === '¤') {\n            ++width;\n          }\n          switch (width) {\n            case 1:\n              return {\n                char: char,\n                currency: 'default',\n                width: width\n              };\n            case 2:\n              return {\n                char: char,\n                currency: 'iso-code',\n                width: width\n              };\n            case 3:\n              return {\n                char: char,\n                currency: 'full-name',\n                width: width\n              };\n            case 5:\n              return {\n                char: char,\n                currency: 'narrow',\n                width: width\n              };\n            default:\n              {\n                var msg = \"Invalid number (\".concat(width, \") of \\xA4 chars in pattern\");\n                onError(new PatternError('¤', msg));\n                return null;\n              }\n          }\n        }\n      case '*':\n        {\n          var pad = src[pos + 1];\n          if (pad) return {\n            char: char,\n            pad: pad,\n            width: 2\n          };\n          break;\n        }\n      case '+':\n      case '-':\n        return {\n          char: char,\n          width: 1\n        };\n      case \"'\":\n        {\n          var str = src[++pos];\n          var _width = 2;\n          if (str === \"'\") return {\n            char: char,\n            str: str,\n            width: _width\n          };\n          while (true) {\n            var next = src[++pos];\n            ++_width;\n            if (next === undefined) {\n              var _msg = \"Unterminated quoted literal in pattern: \".concat(str);\n              onError(new PatternError(\"'\", _msg));\n              return {\n                char: char,\n                str: str,\n                width: _width\n              };\n            } else if (next === \"'\") {\n              if (src[++pos] !== \"'\") return {\n                char: char,\n                str: str,\n                width: _width\n              };else ++_width;\n            }\n            str += next;\n          }\n        }\n    }\n    return null;\n  }\n  var isDigit = function isDigit(char) {\n    return char >= '0' && char <= '9';\n  };\n  function parseNumberToken(src, pos) {\n    var char = src[pos];\n    if (isDigit(char)) {\n      var digits = char;\n      while (true) {\n        var next = src[++pos];\n        if (isDigit(next)) digits += next;else return {\n          char: '0',\n          digits: digits,\n          width: digits.length\n        };\n      }\n    }\n    switch (char) {\n      case '#':\n        {\n          var width = 1;\n          while (src[++pos] === '#') {\n            ++width;\n          }\n          return {\n            char: char,\n            width: width\n          };\n        }\n      case '@':\n        {\n          var min = 1;\n          while (src[++pos] === '@') {\n            ++min;\n          }\n          var _width = min;\n          pos -= 1;\n          while (src[++pos] === '#') {\n            ++_width;\n          }\n          return {\n            char: char,\n            min: min,\n            width: _width\n          };\n        }\n      case 'E':\n        {\n          var plus = src[pos + 1] === '+';\n          if (plus) ++pos;\n          var expDigits = 0;\n          while (src[++pos] === '0') {\n            ++expDigits;\n          }\n          var _width2 = (plus ? 2 : 1) + expDigits;\n          if (expDigits) return {\n            char: char,\n            expDigits: expDigits,\n            plus: plus,\n            width: _width2\n          };else break;\n        }\n      case '.':\n      case ',':\n        return {\n          char: char,\n          width: 1\n        };\n    }\n    return null;\n  }\n  function parseSubpattern(src, pos, onError) {\n    var State = /*#__PURE__*/(() => {\n      (function (State) {\n        State[State[\"Prefix\"] = 0] = \"Prefix\";\n        State[State[\"Number\"] = 1] = \"Number\";\n        State[State[\"Suffix\"] = 2] = \"Suffix\";\n      })(State || (State = {}));\n      return State;\n    })();\n    var prefix = [];\n    var number = [];\n    var suffix = [];\n    var state = State.Prefix;\n    var str = '';\n    while (pos < src.length) {\n      var char = src[pos];\n      if (char === ';') {\n        pos += 1;\n        break;\n      }\n      switch (state) {\n        case State.Prefix:\n          {\n            var token = parseAffixToken(src, pos, onError);\n            if (token) {\n              if (str) {\n                prefix.push({\n                  char: \"'\",\n                  str: str,\n                  width: str.length\n                });\n                str = '';\n              }\n              prefix.push(token);\n              pos += token.width;\n            } else {\n              var _token = parseNumberToken(src, pos);\n              if (_token) {\n                if (str) {\n                  prefix.push({\n                    char: \"'\",\n                    str: str,\n                    width: str.length\n                  });\n                  str = '';\n                }\n                state = State.Number;\n                number.push(_token);\n                pos += _token.width;\n              } else {\n                str += char;\n                pos += 1;\n              }\n            }\n            break;\n          }\n        case State.Number:\n          {\n            var _token2 = parseNumberToken(src, pos);\n            if (_token2) {\n              number.push(_token2);\n              pos += _token2.width;\n            } else {\n              state = State.Suffix;\n            }\n            break;\n          }\n        case State.Suffix:\n          {\n            var _token3 = parseAffixToken(src, pos, onError);\n            if (_token3) {\n              if (str) {\n                suffix.push({\n                  char: \"'\",\n                  str: str,\n                  width: str.length\n                });\n                str = '';\n              }\n              suffix.push(_token3);\n              pos += _token3.width;\n            } else {\n              str += char;\n              pos += 1;\n            }\n            break;\n          }\n      }\n    }\n    if (str) suffix.push({\n      char: \"'\",\n      str: str,\n      width: str.length\n    });\n    return {\n      pattern: {\n        prefix: prefix,\n        number: number,\n        suffix: suffix\n      },\n      pos: pos\n    };\n  }\n  function parseTokens(src, onError) {\n    var _parseSubpattern = parseSubpattern(src, 0, onError),\n      pattern = _parseSubpattern.pattern,\n      pos = _parseSubpattern.pos;\n    if (pos < src.length) {\n      var _parseSubpattern2 = parseSubpattern(src, pos, onError),\n        negative = _parseSubpattern2.pattern;\n      return {\n        tokens: pattern,\n        negative: negative\n      };\n    }\n    return {\n      tokens: pattern\n    };\n  }\n  function parseNumberAsSkeleton(tokens, onError) {\n    var res = {};\n    var hasGroups = false;\n    var hasExponent = false;\n    var intOptional = 0;\n    var intDigits = '';\n    var decimalPos = -1;\n    var fracDigits = '';\n    var fracOptional = 0;\n    for (var pos = 0; pos < tokens.length; ++pos) {\n      var token = tokens[pos];\n      switch (token.char) {\n        case '#':\n          {\n            if (decimalPos === -1) {\n              if (intDigits) {\n                var msg = 'Pattern has # after integer digits';\n                onError(new PatternError('#', msg));\n              }\n              intOptional += token.width;\n            } else {\n              fracOptional += token.width;\n            }\n            break;\n          }\n        case '0':\n          {\n            if (decimalPos === -1) {\n              intDigits += token.digits;\n            } else {\n              if (fracOptional) {\n                var _msg = 'Pattern has digits after # in fraction';\n                onError(new PatternError('0', _msg));\n              }\n              fracDigits += token.digits;\n            }\n            break;\n          }\n        case '@':\n          {\n            if (res.precision) onError(new MaskedValueError('precision', res.precision));\n            res.precision = {\n              style: 'precision-fraction',\n              minSignificant: token.min,\n              maxSignificant: token.width\n            };\n            break;\n          }\n        case ',':\n          hasGroups = true;\n          break;\n        case '.':\n          if (decimalPos === 1) {\n            var _msg2 = 'Pattern has more than one decimal separator';\n            onError(new PatternError('.', _msg2));\n          }\n          decimalPos = pos;\n          break;\n        case 'E':\n          {\n            if (hasExponent) onError(new MaskedValueError('exponent', res.notation));\n            if (hasGroups) {\n              var _msg3 = 'Exponential patterns may not contain grouping separators';\n              onError(new PatternError('E', _msg3));\n            }\n            res.notation = {\n              style: 'scientific'\n            };\n            if (token.expDigits > 1) res.notation.expDigits = token.expDigits;\n            if (token.plus) res.notation.expSign = 'sign-always';\n            hasExponent = true;\n          }\n      }\n    } // imprecise mapping due to paradigm differences\n\n    if (hasGroups) res.group = 'group-auto';else if (intOptional + intDigits.length > 3) res.group = 'group-off';\n    var increment = Number(\"\".concat(intDigits || '0', \".\").concat(fracDigits));\n    if (increment) res.precision = {\n      style: 'precision-increment',\n      increment: increment\n    };\n    if (!hasExponent) {\n      if (intDigits.length > 1) res.integerWidth = {\n        min: intDigits.length\n      };\n      if (!res.precision && (fracDigits.length || fracOptional)) {\n        res.precision = {\n          style: 'precision-fraction',\n          minFraction: fracDigits.length,\n          maxFraction: fracDigits.length + fracOptional\n        };\n      }\n    } else {\n      if (!res.precision || increment) {\n        res.integerWidth = intOptional ? {\n          min: 1,\n          max: intOptional + intDigits.length\n        } : {\n          min: Math.max(1, intDigits.length)\n        };\n      }\n      if (res.precision) {\n        if (!increment) res.integerWidth = {\n          min: 1,\n          max: 1\n        };\n      } else {\n        var dc = intDigits.length + fracDigits.length;\n        if (decimalPos === -1) {\n          if (dc > 0) res.precision = {\n            style: 'precision-fraction',\n            maxSignificant: dc\n          };\n        } else {\n          res.precision = {\n            style: 'precision-fraction',\n            maxSignificant: Math.max(1, dc) + fracOptional\n          };\n          if (dc > 1) res.precision.minSignificant = dc;\n        }\n      }\n    }\n    return res;\n  }\n  function handleAffix(affixTokens, res, currency, onError, isPrefix) {\n    var inFmt = false;\n    var str = '';\n    var _iterator = _createForOfIteratorHelper(affixTokens),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var token = _step.value;\n        switch (token.char) {\n          case '%':\n            res.unit = {\n              style: token.style\n            };\n            if (isPrefix) inFmt = true;else str = '';\n            break;\n          case '¤':\n            if (!currency) {\n              var msg = \"The \\xA4 pattern requires a currency\";\n              onError(new PatternError('¤', msg));\n              break;\n            }\n            res.unit = {\n              style: 'currency',\n              currency: currency\n            };\n            switch (token.currency) {\n              case 'iso-code':\n                res.unitWidth = 'unit-width-iso-code';\n                break;\n              case 'full-name':\n                res.unitWidth = 'unit-width-full-name';\n                break;\n              case 'narrow':\n                res.unitWidth = 'unit-width-narrow';\n                break;\n            }\n            if (isPrefix) inFmt = true;else str = '';\n            break;\n          case '*':\n            // TODO\n            break;\n          case '+':\n            if (!inFmt) str += '+';\n            break;\n          case \"'\":\n            if (!inFmt) str += token.str;\n            break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return str;\n  }\n  function getNegativeAffix(affixTokens, isPrefix) {\n    var inFmt = false;\n    var str = '';\n    var _iterator2 = _createForOfIteratorHelper(affixTokens),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var token = _step2.value;\n        switch (token.char) {\n          case '%':\n          case '¤':\n            if (isPrefix) inFmt = true;else str = '';\n            break;\n          case '-':\n            if (!inFmt) str += '-';\n            break;\n          case \"'\":\n            if (!inFmt) str += token.str;\n            break;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    return str;\n  }\n  /**\n   * Parse an {@link\n   * http://unicode.org/reports/tr35/tr35-numbers.html#Number_Format_Patterns |\n   * ICU NumberFormatter pattern} string into a {@link Skeleton} structure.\n   *\n   * @public\n   * @param src - The pattern string\n   * @param currency - If the pattern includes ¤ tokens, their skeleton\n   *   representation requires a three-letter currency code.\n   * @param onError - Called when the parser encounters a syntax error. The\n   *   function will still return a {@link Skeleton}, but it will be incomplete\n   *   and/or inaccurate. If not defined, the error will be thrown instead.\n   *\n   * @remarks\n   * Unlike the skeleton parser, the pattern parser is not able to return partial\n   * results on error, and will instead throw. Output padding is not supported.\n   *\n   * @example\n   * ```js\n   * import { parseNumberPattern } from '@messageformat/number-skeleton'\n   *\n   * parseNumberPattern('#,##0.00 ¤', 'EUR', console.error)\n   * // {\n   * //   group: 'group-auto',\n   * //   precision: {\n   * //     style: 'precision-fraction',\n   * //     minFraction: 2,\n   * //     maxFraction: 2\n   * //   },\n   * //   unit: { style: 'currency', currency: 'EUR' }\n   * // }\n   * ```\n   */\n\n  function parseNumberPattern(src, currency) {\n    var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (error) {\n      throw error;\n    };\n    var _parseTokens = parseTokens(src, onError),\n      tokens = _parseTokens.tokens,\n      negative = _parseTokens.negative;\n    var res = parseNumberAsSkeleton(tokens.number, onError);\n    var prefix = handleAffix(tokens.prefix, res, currency, onError, true);\n    var suffix = handleAffix(tokens.suffix, res, currency, onError, false);\n    if (negative) {\n      var negPrefix = getNegativeAffix(negative.prefix, true);\n      var negSuffix = getNegativeAffix(negative.suffix, false);\n      res.affix = {\n        pos: [prefix, suffix],\n        neg: [negPrefix, negSuffix]\n      };\n      res.sign = 'sign-never';\n    } else if (prefix || suffix) {\n      res.affix = {\n        pos: [prefix, suffix]\n      };\n    }\n    return res;\n  }\n\n  /** @internal */\n  function isNumberingSystem(ns) {\n    var systems = ['arab', 'arabext', 'bali', 'beng', 'deva', 'fullwide', 'gujr', 'guru', 'hanidec', 'khmr', 'knda', 'laoo', 'latn', 'limb', 'mlym', 'mong', 'mymr', 'orya', 'tamldec', 'telu', 'thai', 'tibt'];\n    return systems.indexOf(ns) !== -1;\n  }\n\n  // FIXME: subtype is not checked\n\n  /** @internal */\n  function isUnit(unit) {\n    var types = ['acceleration', 'angle', 'area', 'concentr', 'consumption', 'digital', 'duration', 'electric', 'energy', 'force', 'frequency', 'graphics', 'length', 'light', 'mass', 'power', 'pressure', 'speed', 'temperature', 'torque', 'volume'];\n    var _unit$split = unit.split('-', 1),\n      _unit$split2 = _slicedToArray(_unit$split, 1),\n      type = _unit$split2[0];\n    return types.indexOf(type) !== -1;\n  }\n  var maxOptions = {\n    'compact-short': 0,\n    'compact-long': 0,\n    'notation-simple': 0,\n    scientific: 2,\n    engineering: 2,\n    percent: 0,\n    permille: 0,\n    'base-unit': 0,\n    currency: 1,\n    'measure-unit': 1,\n    'per-measure-unit': 1,\n    'unit-width-narrow': 0,\n    'unit-width-short': 0,\n    'unit-width-full-name': 0,\n    'unit-width-iso-code': 0,\n    'unit-width-hidden': 0,\n    'precision-integer': 0,\n    'precision-unlimited': 0,\n    'precision-currency-standard': 0,\n    'precision-currency-cash': 0,\n    'precision-increment': 1,\n    'rounding-mode-ceiling': 0,\n    'rounding-mode-floor': 0,\n    'rounding-mode-down': 0,\n    'rounding-mode-up': 0,\n    'rounding-mode-half-even': 0,\n    'rounding-mode-half-down': 0,\n    'rounding-mode-half-up': 0,\n    'rounding-mode-unnecessary': 0,\n    'integer-width': 1,\n    scale: 1,\n    'group-off': 0,\n    'group-min2': 0,\n    'group-auto': 0,\n    'group-on-aligned': 0,\n    'group-thousands': 0,\n    latin: 0,\n    'numbering-system': 1,\n    'sign-auto': 0,\n    'sign-always': 0,\n    'sign-never': 0,\n    'sign-accounting': 0,\n    'sign-accounting-always': 0,\n    'sign-except-zero': 0,\n    'sign-accounting-except-zero': 0,\n    'decimal-auto': 0,\n    'decimal-always': 0\n  };\n  var minOptions = {\n    currency: 1,\n    'integer-width': 1,\n    'measure-unit': 1,\n    'numbering-system': 1,\n    'per-measure-unit': 1,\n    'precision-increment': 1,\n    scale: 1\n  };\n  function hasMaxOption(stem) {\n    return stem in maxOptions;\n  }\n  function hasMinOption(stem) {\n    return stem in minOptions;\n  }\n  /** @internal */\n\n  function validOptions(stem, options, onError) {\n    if (hasMaxOption(stem)) {\n      var maxOpt = maxOptions[stem];\n      if (options.length > maxOpt) {\n        if (maxOpt === 0) {\n          var _iterator = _createForOfIteratorHelper(options),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var opt = _step.value;\n              onError(new BadOptionError(stem, opt));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        } else {\n          onError(new TooManyOptionsError(stem, options, maxOpt));\n        }\n        return false;\n      } else if (hasMinOption(stem) && options.length < minOptions[stem]) {\n        onError(new MissingOptionError(stem));\n        return false;\n      }\n    }\n    return true;\n  }\n  function parseBlueprintDigits(src, style) {\n    var re = style === 'fraction' ? /^\\.(0*)(\\+|#*)$/ : /^(@+)(\\+|#*)$/;\n    var match = src && src.match(re);\n    if (match) {\n      var min = match[1].length;\n      switch (match[2].charAt(0)) {\n        case '':\n          return {\n            min: min,\n            max: min\n          };\n        case '+':\n          return {\n            min: min,\n            max: null\n          };\n        case '#':\n          {\n            return {\n              min: min,\n              max: min + match[2].length\n            };\n          }\n      }\n    }\n    return null;\n  }\n  function parsePrecisionBlueprint(stem, options, onError) {\n    var fd = parseBlueprintDigits(stem, 'fraction');\n    if (fd) {\n      if (options.length > 1) onError(new TooManyOptionsError(stem, options, 1));\n      var res = {\n        style: 'precision-fraction',\n        source: stem,\n        minFraction: fd.min\n      };\n      if (fd.max != null) res.maxFraction = fd.max;\n      var option = options[0];\n      var _sd = parseBlueprintDigits(option, 'significant');\n      if (_sd) {\n        res.source = \"\".concat(stem, \"/\").concat(option);\n        res.minSignificant = _sd.min;\n        if (_sd.max != null) res.maxSignificant = _sd.max;\n      } else if (option) onError(new BadOptionError(stem, option));\n      return res;\n    }\n    var sd = parseBlueprintDigits(stem, 'significant');\n    if (sd) {\n      var _iterator = _createForOfIteratorHelper(options),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var opt = _step.value;\n          onError(new BadOptionError(stem, opt));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var _res = {\n        style: 'precision-fraction',\n        source: stem,\n        minSignificant: sd.min\n      };\n      if (sd.max != null) _res.maxSignificant = sd.max;\n      return _res;\n    }\n    return null;\n  }\n\n  /** @internal */\n\n  var TokenParser = /*#__PURE__*/function () {\n    function TokenParser(onError) {\n      _classCallCheck(this, TokenParser);\n      this.skeleton = {};\n      this.onError = onError;\n    }\n    _createClass(TokenParser, [{\n      key: \"badOption\",\n      value: function badOption(stem, opt) {\n        this.onError(new BadOptionError(stem, opt));\n      }\n    }, {\n      key: \"assertEmpty\",\n      value: function assertEmpty(key) {\n        var prev = this.skeleton[key];\n        if (prev) this.onError(new MaskedValueError(key, prev));\n      }\n    }, {\n      key: \"parseToken\",\n      value: function parseToken(stem, options) {\n        if (!validOptions(stem, options, this.onError)) return;\n        var option = options[0];\n        var res = this.skeleton;\n        switch (stem) {\n          // notation\n          case 'compact-short':\n          case 'compact-long':\n          case 'notation-simple':\n            this.assertEmpty('notation');\n            res.notation = {\n              style: stem\n            };\n            break;\n          case 'scientific':\n          case 'engineering':\n            {\n              var expDigits = null;\n              var expSign = undefined;\n              var _iterator = _createForOfIteratorHelper(options),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var opt = _step.value;\n                  switch (opt) {\n                    case 'sign-auto':\n                    case 'sign-always':\n                    case 'sign-never':\n                    case 'sign-accounting':\n                    case 'sign-accounting-always':\n                    case 'sign-except-zero':\n                    case 'sign-accounting-except-zero':\n                      expSign = opt;\n                      break;\n                    default:\n                      if (/^\\+e+$/.test(opt)) expDigits = opt.length - 1;else {\n                        this.badOption(stem, opt);\n                      }\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              this.assertEmpty('notation');\n              var source = options.join('/');\n              res.notation = expDigits && expSign ? {\n                style: stem,\n                source: source,\n                expDigits: expDigits,\n                expSign: expSign\n              } : expDigits ? {\n                style: stem,\n                source: source,\n                expDigits: expDigits\n              } : expSign ? {\n                style: stem,\n                source: source,\n                expSign: expSign\n              } : {\n                style: stem,\n                source: source\n              };\n              break;\n            }\n          // unit\n\n          case 'percent':\n          case 'permille':\n          case 'base-unit':\n            this.assertEmpty('unit');\n            res.unit = {\n              style: stem\n            };\n            break;\n          case 'currency':\n            if (/^[A-Z]{3}$/.test(option)) {\n              this.assertEmpty('unit');\n              res.unit = {\n                style: stem,\n                currency: option\n              };\n            } else this.badOption(stem, option);\n            break;\n          case 'measure-unit':\n            {\n              if (isUnit(option)) {\n                this.assertEmpty('unit');\n                res.unit = {\n                  style: stem,\n                  unit: option\n                };\n              } else this.badOption(stem, option);\n              break;\n            }\n          // unitPer\n\n          case 'per-measure-unit':\n            {\n              if (isUnit(option)) {\n                this.assertEmpty('unitPer');\n                res.unitPer = option;\n              } else this.badOption(stem, option);\n              break;\n            }\n          // unitWidth\n\n          case 'unit-width-narrow':\n          case 'unit-width-short':\n          case 'unit-width-full-name':\n          case 'unit-width-iso-code':\n          case 'unit-width-hidden':\n            this.assertEmpty('unitWidth');\n            res.unitWidth = stem;\n            break;\n          // precision\n\n          case 'precision-integer':\n          case 'precision-unlimited':\n          case 'precision-currency-standard':\n          case 'precision-currency-cash':\n            this.assertEmpty('precision');\n            res.precision = {\n              style: stem\n            };\n            break;\n          case 'precision-increment':\n            {\n              var increment = Number(option);\n              if (increment > 0) {\n                this.assertEmpty('precision');\n                res.precision = {\n                  style: stem,\n                  increment: increment\n                };\n              } else this.badOption(stem, option);\n              break;\n            }\n          // roundingMode\n\n          case 'rounding-mode-ceiling':\n          case 'rounding-mode-floor':\n          case 'rounding-mode-down':\n          case 'rounding-mode-up':\n          case 'rounding-mode-half-even':\n          case 'rounding-mode-half-down':\n          case 'rounding-mode-half-up':\n          case 'rounding-mode-unnecessary':\n            this.assertEmpty('roundingMode');\n            res.roundingMode = stem;\n            break;\n          // integerWidth\n\n          case 'integer-width':\n            {\n              if (/^\\+0*$/.test(option)) {\n                this.assertEmpty('integerWidth');\n                res.integerWidth = {\n                  source: option,\n                  min: option.length - 1\n                };\n              } else {\n                var m = option.match(/^#*(0*)$/);\n                if (m) {\n                  this.assertEmpty('integerWidth');\n                  res.integerWidth = {\n                    source: option,\n                    min: m[1].length,\n                    max: m[0].length\n                  };\n                } else this.badOption(stem, option);\n              }\n              break;\n            }\n          // scale\n\n          case 'scale':\n            {\n              var scale = Number(option);\n              if (scale > 0) {\n                this.assertEmpty('scale');\n                res.scale = scale;\n              } else this.badOption(stem, option);\n              break;\n            }\n          // group\n\n          case 'group-off':\n          case 'group-min2':\n          case 'group-auto':\n          case 'group-on-aligned':\n          case 'group-thousands':\n            this.assertEmpty('group');\n            res.group = stem;\n            break;\n          // numberingSystem\n\n          case 'latin':\n            this.assertEmpty('numberingSystem');\n            res.numberingSystem = 'latn';\n            break;\n          case 'numbering-system':\n            {\n              if (isNumberingSystem(option)) {\n                this.assertEmpty('numberingSystem');\n                res.numberingSystem = option;\n              } else this.badOption(stem, option);\n              break;\n            }\n          // sign\n\n          case 'sign-auto':\n          case 'sign-always':\n          case 'sign-never':\n          case 'sign-accounting':\n          case 'sign-accounting-always':\n          case 'sign-except-zero':\n          case 'sign-accounting-except-zero':\n            this.assertEmpty('sign');\n            res.sign = stem;\n            break;\n          // decimal\n\n          case 'decimal-auto':\n          case 'decimal-always':\n            this.assertEmpty('decimal');\n            res.decimal = stem;\n            break;\n          // precision blueprint\n\n          default:\n            {\n              var precision = parsePrecisionBlueprint(stem, options, this.onError);\n              if (precision) {\n                this.assertEmpty('precision');\n                res.precision = precision;\n              } else {\n                this.onError(new BadStemError(stem));\n              }\n            }\n        }\n      }\n    }]);\n    return TokenParser;\n  }();\n\n  /**\n   * Parse an {@link\n   * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md\n   * | ICU NumberFormatter skeleton} string into a {@link Skeleton} structure.\n   *\n   * @public\n   * @param src - The skeleton string\n   * @param onError - Called when the parser encounters a syntax error. The\n   *   function will still return a {@link Skeleton}, but it may not contain\n   *   information for all tokens. If not defined, the error will be thrown\n   *   instead.\n   *\n   * @example\n   * ```js\n   * import { parseNumberSkeleton } from '@messageformat/number-skeleton'\n   *\n   * parseNumberSkeleton('compact-short currency/GBP', console.error)\n   * // {\n   * //   notation: { style: 'compact-short' },\n   * //   unit: { style: 'currency', currency: 'GBP' }\n   * // }\n   * ```\n   */\n\n  function parseNumberSkeleton(src) {\n    var onError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (error) {\n      throw error;\n    };\n    var tokens = [];\n    var _iterator = _createForOfIteratorHelper(src.split(' ')),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var part = _step.value;\n        if (part) {\n          var _options = part.split('/');\n          var _stem = _options.shift() || '';\n          tokens.push({\n            stem: _stem,\n            options: _options\n          });\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var parser = new TokenParser(onError);\n    for (var _i = 0, _tokens = tokens; _i < _tokens.length; _i++) {\n      var _tokens$_i = _tokens[_i],\n        stem = _tokens$_i.stem,\n        options = _tokens$_i.options;\n      parser.parseToken(stem, options);\n    }\n    return parser.skeleton;\n  }\n\n  /**\n   * Returns a number formatter function for the given locales and number skeleton\n   *\n   * @remarks\n   * Uses `Intl.NumberFormat` (ES2020) internally.\n   *\n   * @public\n   * @param locales - One or more valid BCP 47 language tags, e.g. `fr` or `en-CA`\n   * @param skeleton - An ICU NumberFormatter pattern or `::`-prefixed skeleton\n   *   string, or a parsed `Skeleton` structure\n   * @param currency - If `skeleton` is a pattern string that includes ¤ tokens,\n   *   their skeleton representation requires a three-letter currency code.\n   * @param onError - If defined, will be called separately for each encountered\n   *   parsing error and unsupported feature.\n   * @example\n   * ```js\n   * import { getNumberFormatter } from '@messageformat/number-skeleton'\n   *\n   * let src = ':: currency/CAD unit-width-narrow'\n   * let fmt = getNumberFormatter('en-CA', src, console.error)\n   * fmt(42) // '$42.00'\n   *\n   * src = '::percent scale/100'\n   * fmt = getNumberFormatter('en', src, console.error)\n   * fmt(0.3) // '30%'\n   * ```\n   */\n\n  function getNumberFormatter(locales, skeleton, currency, onError) {\n    if (typeof skeleton === 'string') {\n      skeleton = skeleton.indexOf('::') === 0 ? parseNumberSkeleton(skeleton.slice(2), onError) : parseNumberPattern(skeleton, currency, onError);\n    }\n    var lc = getNumberFormatLocales(locales, skeleton);\n    var opt = getNumberFormatOptions(skeleton, onError);\n    var mod = getNumberFormatModifier(skeleton);\n    var nf = new Intl.NumberFormat(lc, opt);\n    if (skeleton.affix) {\n      var _skeleton$affix$pos = _slicedToArray(skeleton.affix.pos, 2),\n        p0 = _skeleton$affix$pos[0],\n        p1 = _skeleton$affix$pos[1];\n      var _ref = skeleton.affix.neg || ['', ''],\n        _ref2 = _slicedToArray(_ref, 2),\n        n0 = _ref2[0],\n        n1 = _ref2[1];\n      return function (value) {\n        var n = nf.format(mod(value));\n        return value < 0 ? \"\".concat(n0).concat(n).concat(n1) : \"\".concat(p0).concat(n).concat(p1);\n      };\n    }\n    return function (value) {\n      return nf.format(mod(value));\n    };\n  }\n  /**\n   * Returns a string of JavaScript source that evaluates to a number formatter\n   * function with the same `(value: number) => string` signature as the function\n   * returned by {@link getNumberFormatter}.\n   *\n   * @remarks\n   * The returned function will memoize an `Intl.NumberFormat` instance.\n   *\n   * @public\n   * @param locales - One or more valid BCP 47 language tags, e.g. `fr` or `en-CA`\n   * @param skeleton - An ICU NumberFormatter pattern or `::`-prefixed skeleton\n   *   string, or a parsed `Skeleton` structure\n   * @param currency - If `skeleton` is a pattern string that includes ¤ tokens,\n   *   their skeleton representation requires a three-letter currency code.\n   * @param onError - If defined, will be called separately for each encountered\n   *   parsing error and unsupported feature.\n   * @example\n   * ```js\n   * import { getNumberFormatterSource } from '@messageformat/number-skeleton'\n   *\n   * getNumberFormatterSource('en', '::percent', console.error)\n   * // '(function() {\\n' +\n   * // '  var opt = {\"style\":\"percent\"};\\n' +\n   * // '  var nf = new Intl.NumberFormat([\"en\"], opt);\\n' +\n   * // '  var mod = function(n) { return n * 0.01; };\\n' +\n   * // '  return function(value) { return nf.format(mod(value)); }\\n' +\n   * // '})()'\n   *\n   * const src = getNumberFormatterSource('en-CA', ':: currency/CAD unit-width-narrow', console.error)\n   * // '(function() {\\n' +\n   * // '  var opt = {\"style\":\"currency\",\"currency\":\"CAD\",\"currencyDisplay\":\"narrowSymbol\",\"unitDisplay\":\"narrow\"};\\n' +\n   * // '  var nf = new Intl.NumberFormat([\"en-CA\"], opt);\\n'\n   * // '  return function(value) { return nf.format(value); }\\n' +\n   * // '})()'\n   * const fmt = new Function(`return ${src}`)()\n   * fmt(42) // '$42.00'\n   * ```\n   */\n\n  function getNumberFormatterSource(locales, skeleton, currency, onError) {\n    if (typeof skeleton === 'string') {\n      skeleton = skeleton.indexOf('::') === 0 ? parseNumberSkeleton(skeleton.slice(2), onError) : parseNumberPattern(skeleton, currency, onError);\n    }\n    var lc = getNumberFormatLocales(locales, skeleton);\n    var opt = getNumberFormatOptions(skeleton, onError);\n    var modSrc = getNumberFormatModifierSource(skeleton);\n    var lines = [\"(function() {\", \"var opt = \".concat(JSON.stringify(opt), \";\"), \"var nf = new Intl.NumberFormat(\".concat(JSON.stringify(lc), \", opt);\")];\n    var res = 'nf.format(value)';\n    if (modSrc) {\n      lines.push(\"var mod = \".concat(modSrc, \";\"));\n      res = 'nf.format(mod(value))';\n    }\n    if (skeleton.affix) {\n      var _skeleton$affix$pos$m = skeleton.affix.pos.map(function (s) {\n          return JSON.stringify(s);\n        }),\n        _skeleton$affix$pos$m2 = _slicedToArray(_skeleton$affix$pos$m, 2),\n        p0 = _skeleton$affix$pos$m2[0],\n        p1 = _skeleton$affix$pos$m2[1];\n      if (skeleton.affix.neg) {\n        var _skeleton$affix$neg$m = skeleton.affix.neg.map(function (s) {\n            return JSON.stringify(s);\n          }),\n          _skeleton$affix$neg$m2 = _slicedToArray(_skeleton$affix$neg$m, 2),\n          n0 = _skeleton$affix$neg$m2[0],\n          n1 = _skeleton$affix$neg$m2[1];\n        res = \"value < 0 ? \".concat(n0, \" + \").concat(res, \" + \").concat(n1, \" : \").concat(p0, \" + \").concat(res, \" + \").concat(p1);\n      } else {\n        res = \"\".concat(p0, \" + \").concat(res, \" + \").concat(p1);\n      }\n    }\n    lines.push(\"return function(value) { return \".concat(res, \"; }\"));\n    return lines.join('\\n  ') + '\\n})()';\n  }\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n  var parser = {};\n  var lexer = {};\n  var moo = {\n    exports: {}\n  };\n  (function (module) {\n    (function (root, factory) {\n      if (module.exports) {\n        module.exports = factory();\n      } else {\n        root.moo = factory();\n      }\n    })(commonjsGlobal, function () {\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      var toString = Object.prototype.toString;\n      var hasSticky = typeof new RegExp().sticky === 'boolean';\n      /***************************************************************************/\n\n      function isRegExp(o) {\n        return o && toString.call(o) === '[object RegExp]';\n      }\n      function isObject(o) {\n        return o && _typeof(o) === 'object' && !isRegExp(o) && !Array.isArray(o);\n      }\n      function reEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n      }\n      function reGroups(s) {\n        var re = new RegExp('|' + s);\n        return re.exec('').length - 1;\n      }\n      function reCapture(s) {\n        return '(' + s + ')';\n      }\n      function reUnion(regexps) {\n        if (!regexps.length) return '(?!)';\n        var source = regexps.map(function (s) {\n          return \"(?:\" + s + \")\";\n        }).join('|');\n        return \"(?:\" + source + \")\";\n      }\n      function regexpOrLiteral(obj) {\n        if (typeof obj === 'string') {\n          return '(?:' + reEscape(obj) + ')';\n        } else if (isRegExp(obj)) {\n          // TODO: consider /u support\n          if (obj.ignoreCase) throw new Error('RegExp /i flag not allowed');\n          if (obj.global) throw new Error('RegExp /g flag is implied');\n          if (obj.sticky) throw new Error('RegExp /y flag is implied');\n          if (obj.multiline) throw new Error('RegExp /m flag is implied');\n          return obj.source;\n        } else {\n          throw new Error('Not a pattern: ' + obj);\n        }\n      }\n      function objectToRules(object) {\n        var keys = Object.getOwnPropertyNames(object);\n        var result = [];\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          var thing = object[key];\n          var rules = [].concat(thing);\n          if (key === 'include') {\n            for (var j = 0; j < rules.length; j++) {\n              result.push({\n                include: rules[j]\n              });\n            }\n            continue;\n          }\n          var match = [];\n          rules.forEach(function (rule) {\n            if (isObject(rule)) {\n              if (match.length) result.push(ruleOptions(key, match));\n              result.push(ruleOptions(key, rule));\n              match = [];\n            } else {\n              match.push(rule);\n            }\n          });\n          if (match.length) result.push(ruleOptions(key, match));\n        }\n        return result;\n      }\n      function arrayToRules(array) {\n        var result = [];\n        for (var i = 0; i < array.length; i++) {\n          var obj = array[i];\n          if (obj.include) {\n            var include = [].concat(obj.include);\n            for (var j = 0; j < include.length; j++) {\n              result.push({\n                include: include[j]\n              });\n            }\n            continue;\n          }\n          if (!obj.type) {\n            throw new Error('Rule has no type: ' + JSON.stringify(obj));\n          }\n          result.push(ruleOptions(obj.type, obj));\n        }\n        return result;\n      }\n      function ruleOptions(type, obj) {\n        if (!isObject(obj)) {\n          obj = {\n            match: obj\n          };\n        }\n        if (obj.include) {\n          throw new Error('Matching rules cannot also include states');\n        } // nb. error and fallback imply lineBreaks\n\n        var options = {\n          defaultType: type,\n          lineBreaks: !!obj.error || !!obj.fallback,\n          pop: false,\n          next: null,\n          push: null,\n          error: false,\n          fallback: false,\n          value: null,\n          type: null,\n          shouldThrow: false\n        }; // Avoid Object.assign(), so we support IE9+\n\n        for (var key in obj) {\n          if (hasOwnProperty.call(obj, key)) {\n            options[key] = obj[key];\n          }\n        } // type transform cannot be a string\n\n        if (typeof options.type === 'string' && type !== options.type) {\n          throw new Error(\"Type transform cannot be a string (type '\" + options.type + \"' for token '\" + type + \"')\");\n        } // convert to array\n\n        var match = options.match;\n        options.match = Array.isArray(match) ? match : match ? [match] : [];\n        options.match.sort(function (a, b) {\n          return isRegExp(a) && isRegExp(b) ? 0 : isRegExp(b) ? -1 : isRegExp(a) ? +1 : b.length - a.length;\n        });\n        return options;\n      }\n      function toRules(spec) {\n        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);\n      }\n      var defaultErrorRule = ruleOptions('error', {\n        lineBreaks: true,\n        shouldThrow: true\n      });\n      function compileRules(rules, hasStates) {\n        var errorRule = null;\n        var fast = Object.create(null);\n        var fastAllowed = true;\n        var unicodeFlag = null;\n        var groups = [];\n        var parts = []; // If there is a fallback rule, then disable fast matching\n\n        for (var i = 0; i < rules.length; i++) {\n          if (rules[i].fallback) {\n            fastAllowed = false;\n          }\n        }\n        for (var i = 0; i < rules.length; i++) {\n          var options = rules[i];\n          if (options.include) {\n            // all valid inclusions are removed by states() preprocessor\n            throw new Error('Inheritance is not allowed in stateless lexers');\n          }\n          if (options.error || options.fallback) {\n            // errorRule can only be set once\n            if (errorRule) {\n              if (!options.fallback === !errorRule.fallback) {\n                throw new Error(\"Multiple \" + (options.fallback ? \"fallback\" : \"error\") + \" rules not allowed (for token '\" + options.defaultType + \"')\");\n              } else {\n                throw new Error(\"fallback and error are mutually exclusive (for token '\" + options.defaultType + \"')\");\n              }\n            }\n            errorRule = options;\n          }\n          var match = options.match.slice();\n          if (fastAllowed) {\n            while (match.length && typeof match[0] === 'string' && match[0].length === 1) {\n              var word = match.shift();\n              fast[word.charCodeAt(0)] = options;\n            }\n          } // Warn about inappropriate state-switching options\n\n          if (options.pop || options.push || options.next) {\n            if (!hasStates) {\n              throw new Error(\"State-switching options are not allowed in stateless lexers (for token '\" + options.defaultType + \"')\");\n            }\n            if (options.fallback) {\n              throw new Error(\"State-switching options are not allowed on fallback tokens (for token '\" + options.defaultType + \"')\");\n            }\n          } // Only rules with a .match are included in the RegExp\n\n          if (match.length === 0) {\n            continue;\n          }\n          fastAllowed = false;\n          groups.push(options); // Check unicode flag is used everywhere or nowhere\n\n          for (var j = 0; j < match.length; j++) {\n            var obj = match[j];\n            if (!isRegExp(obj)) {\n              continue;\n            }\n            if (unicodeFlag === null) {\n              unicodeFlag = obj.unicode;\n            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {\n              throw new Error('If one rule is /u then all must be');\n            }\n          } // convert to RegExp\n\n          var pat = reUnion(match.map(regexpOrLiteral)); // validate\n\n          var regexp = new RegExp(pat);\n          if (regexp.test(\"\")) {\n            throw new Error(\"RegExp matches empty string: \" + regexp);\n          }\n          var groupCount = reGroups(pat);\n          if (groupCount > 0) {\n            throw new Error(\"RegExp has capture groups: \" + regexp + \"\\nUse (?: … ) instead\");\n          } // try and detect rules matching newlines\n\n          if (!options.lineBreaks && regexp.test('\\n')) {\n            throw new Error('Rule should declare lineBreaks: ' + regexp);\n          } // store regex\n\n          parts.push(reCapture(pat));\n        } // If there's no fallback rule, use the sticky flag so we only look for\n        // matches at the current index.\n        //\n        // If we don't support the sticky flag, then fake it using an irrefutable\n        // match (i.e. an empty pattern).\n\n        var fallbackRule = errorRule && errorRule.fallback;\n        var flags = hasSticky && !fallbackRule ? 'ym' : 'gm';\n        var suffix = hasSticky || fallbackRule ? '' : '|';\n        if (unicodeFlag === true) flags += \"u\";\n        var combined = new RegExp(reUnion(parts) + suffix, flags);\n        return {\n          regexp: combined,\n          groups: groups,\n          fast: fast,\n          error: errorRule || defaultErrorRule\n        };\n      }\n      function compile(rules) {\n        var result = compileRules(toRules(rules));\n        return new Lexer({\n          start: result\n        }, 'start');\n      }\n      function checkStateGroup(g, name, map) {\n        var state = g && (g.push || g.next);\n        if (state && !map[state]) {\n          throw new Error(\"Missing state '\" + state + \"' (in token '\" + g.defaultType + \"' of state '\" + name + \"')\");\n        }\n        if (g && g.pop && +g.pop !== 1) {\n          throw new Error(\"pop must be 1 (in token '\" + g.defaultType + \"' of state '\" + name + \"')\");\n        }\n      }\n      function compileStates(states, start) {\n        var all = states.$all ? toRules(states.$all) : [];\n        delete states.$all;\n        var keys = Object.getOwnPropertyNames(states);\n        if (!start) start = keys[0];\n        var ruleMap = Object.create(null);\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          ruleMap[key] = toRules(states[key]).concat(all);\n        }\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          var rules = ruleMap[key];\n          var included = Object.create(null);\n          for (var j = 0; j < rules.length; j++) {\n            var rule = rules[j];\n            if (!rule.include) continue;\n            var splice = [j, 1];\n            if (rule.include !== key && !included[rule.include]) {\n              included[rule.include] = true;\n              var newRules = ruleMap[rule.include];\n              if (!newRules) {\n                throw new Error(\"Cannot include nonexistent state '\" + rule.include + \"' (in state '\" + key + \"')\");\n              }\n              for (var k = 0; k < newRules.length; k++) {\n                var newRule = newRules[k];\n                if (rules.indexOf(newRule) !== -1) continue;\n                splice.push(newRule);\n              }\n            }\n            rules.splice.apply(rules, splice);\n            j--;\n          }\n        }\n        var map = Object.create(null);\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          map[key] = compileRules(ruleMap[key], true);\n        }\n        for (var i = 0; i < keys.length; i++) {\n          var name = keys[i];\n          var state = map[name];\n          var groups = state.groups;\n          for (var j = 0; j < groups.length; j++) {\n            checkStateGroup(groups[j], name, map);\n          }\n          var fastKeys = Object.getOwnPropertyNames(state.fast);\n          for (var j = 0; j < fastKeys.length; j++) {\n            checkStateGroup(state.fast[fastKeys[j]], name, map);\n          }\n        }\n        return new Lexer(map, start);\n      }\n      function keywordTransform(map) {\n        var reverseMap = Object.create(null);\n        var byLength = Object.create(null);\n        var types = Object.getOwnPropertyNames(map);\n        for (var i = 0; i < types.length; i++) {\n          var tokenType = types[i];\n          var item = map[tokenType];\n          var keywordList = Array.isArray(item) ? item : [item];\n          keywordList.forEach(function (keyword) {\n            (byLength[keyword.length] = byLength[keyword.length] || []).push(keyword);\n            if (typeof keyword !== 'string') {\n              throw new Error(\"keyword must be string (in keyword '\" + tokenType + \"')\");\n            }\n            reverseMap[keyword] = tokenType;\n          });\n        } // fast string lookup\n        // https://jsperf.com/string-lookups\n\n        function str(x) {\n          return JSON.stringify(x);\n        }\n        var source = '';\n        source += 'switch (value.length) {\\n';\n        for (var length in byLength) {\n          var keywords = byLength[length];\n          source += 'case ' + length + ':\\n';\n          source += 'switch (value) {\\n';\n          keywords.forEach(function (keyword) {\n            var tokenType = reverseMap[keyword];\n            source += 'case ' + str(keyword) + ': return ' + str(tokenType) + '\\n';\n          });\n          source += '}\\n';\n        }\n        source += '}\\n';\n        return Function('value', source); // type\n      }\n      /***************************************************************************/\n\n      var Lexer = function Lexer(states, state) {\n        this.startState = state;\n        this.states = states;\n        this.buffer = '';\n        this.stack = [];\n        this.reset();\n      };\n      Lexer.prototype.reset = function (data, info) {\n        this.buffer = data || '';\n        this.index = 0;\n        this.line = info ? info.line : 1;\n        this.col = info ? info.col : 1;\n        this.queuedToken = info ? info.queuedToken : null;\n        this.queuedThrow = info ? info.queuedThrow : null;\n        this.setState(info ? info.state : this.startState);\n        this.stack = info && info.stack ? info.stack.slice() : [];\n        return this;\n      };\n      Lexer.prototype.save = function () {\n        return {\n          line: this.line,\n          col: this.col,\n          state: this.state,\n          stack: this.stack.slice(),\n          queuedToken: this.queuedToken,\n          queuedThrow: this.queuedThrow\n        };\n      };\n      Lexer.prototype.setState = function (state) {\n        if (!state || this.state === state) return;\n        this.state = state;\n        var info = this.states[state];\n        this.groups = info.groups;\n        this.error = info.error;\n        this.re = info.regexp;\n        this.fast = info.fast;\n      };\n      Lexer.prototype.popState = function () {\n        this.setState(this.stack.pop());\n      };\n      Lexer.prototype.pushState = function (state) {\n        this.stack.push(this.state);\n        this.setState(state);\n      };\n      var eat = hasSticky ? function (re, buffer) {\n        // assume re is /y\n        return re.exec(buffer);\n      } : function (re, buffer) {\n        // assume re is /g\n        var match = re.exec(buffer); // will always match, since we used the |(?:) trick\n\n        if (match[0].length === 0) {\n          return null;\n        }\n        return match;\n      };\n      Lexer.prototype._getGroup = function (match) {\n        var groupCount = this.groups.length;\n        for (var i = 0; i < groupCount; i++) {\n          if (match[i + 1] !== undefined) {\n            return this.groups[i];\n          }\n        }\n        throw new Error('Cannot find token type for matched text');\n      };\n      function tokenToString() {\n        return this.value;\n      }\n      Lexer.prototype.next = function () {\n        var index = this.index; // If a fallback token matched, we don't need to re-run the RegExp\n\n        if (this.queuedGroup) {\n          var token = this._token(this.queuedGroup, this.queuedText, index);\n          this.queuedGroup = null;\n          this.queuedText = \"\";\n          return token;\n        }\n        var buffer = this.buffer;\n        if (index === buffer.length) {\n          return; // EOF\n        } // Fast matching for single characters\n\n        var group = this.fast[buffer.charCodeAt(index)];\n        if (group) {\n          return this._token(group, buffer.charAt(index), index);\n        } // Execute RegExp\n\n        var re = this.re;\n        re.lastIndex = index;\n        var match = eat(re, buffer); // Error tokens match the remaining buffer\n\n        var error = this.error;\n        if (match == null) {\n          return this._token(error, buffer.slice(index, buffer.length), index);\n        }\n        var group = this._getGroup(match);\n        var text = match[0];\n        if (error.fallback && match.index !== index) {\n          this.queuedGroup = group;\n          this.queuedText = text; // Fallback tokens contain the unmatched portion of the buffer\n\n          return this._token(error, buffer.slice(index, match.index), index);\n        }\n        return this._token(group, text, index);\n      };\n      Lexer.prototype._token = function (group, text, offset) {\n        // count line breaks\n        var lineBreaks = 0;\n        if (group.lineBreaks) {\n          var matchNL = /\\n/g;\n          var nl = 1;\n          if (text === '\\n') {\n            lineBreaks = 1;\n          } else {\n            while (matchNL.exec(text)) {\n              lineBreaks++;\n              nl = matchNL.lastIndex;\n            }\n          }\n        }\n        var token = {\n          type: typeof group.type === 'function' && group.type(text) || group.defaultType,\n          value: typeof group.value === 'function' ? group.value(text) : text,\n          text: text,\n          toString: tokenToString,\n          offset: offset,\n          lineBreaks: lineBreaks,\n          line: this.line,\n          col: this.col\n        }; // nb. adding more props to token object will make V8 sad!\n\n        var size = text.length;\n        this.index += size;\n        this.line += lineBreaks;\n        if (lineBreaks !== 0) {\n          this.col = size - nl + 1;\n        } else {\n          this.col += size;\n        } // throw, if no rule with {error: true}\n\n        if (group.shouldThrow) {\n          throw new Error(this.formatError(token, \"invalid syntax\"));\n        }\n        if (group.pop) this.popState();else if (group.push) this.pushState(group.push);else if (group.next) this.setState(group.next);\n        return token;\n      };\n      if (typeof Symbol !== 'undefined' && Symbol.iterator) {\n        var LexerIterator = function LexerIterator(lexer) {\n          this.lexer = lexer;\n        };\n        LexerIterator.prototype.next = function () {\n          var token = this.lexer.next();\n          return {\n            value: token,\n            done: !token\n          };\n        };\n        LexerIterator.prototype[Symbol.iterator] = function () {\n          return this;\n        };\n        Lexer.prototype[Symbol.iterator] = function () {\n          return new LexerIterator(this);\n        };\n      }\n      Lexer.prototype.formatError = function (token, message) {\n        if (token == null) {\n          // An undefined token indicates EOF\n          var text = this.buffer.slice(this.index);\n          var token = {\n            text: text,\n            offset: this.index,\n            lineBreaks: text.indexOf('\\n') === -1 ? 0 : 1,\n            line: this.line,\n            col: this.col\n          };\n        }\n        var start = Math.max(0, token.offset - token.col + 1);\n        var eol = token.lineBreaks ? token.text.indexOf('\\n') : token.text.length;\n        var firstLine = this.buffer.substring(start, token.offset + eol);\n        message += \" at line \" + token.line + \" col \" + token.col + \":\\n\\n\";\n        message += \"  \" + firstLine + \"\\n\";\n        message += \"  \" + Array(token.col).join(\" \") + \"^\";\n        return message;\n      };\n      Lexer.prototype.clone = function () {\n        return new Lexer(this.states, this.state);\n      };\n      Lexer.prototype.has = function (tokenType) {\n        return true;\n      };\n      return {\n        compile: compile,\n        states: compileStates,\n        error: Object.freeze({\n          error: true\n        }),\n        fallback: Object.freeze({\n          fallback: true\n        }),\n        keywords: keywordTransform\n      };\n    });\n  })(moo);\n  (function (exports) {\n    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {\n      return mod && mod.__esModule ? mod : {\n        \"default\": mod\n      };\n    };\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.lexer = exports.states = void 0;\n    var moo_1 = __importDefault(moo.exports);\n    exports.states = {\n      body: {\n        doubleapos: {\n          match: \"''\",\n          value: function value() {\n            return \"'\";\n          }\n        },\n        quoted: {\n          lineBreaks: true,\n          match: /'[#\\{\\}](?:(?:(?![])[\\s\\S])*?(?:(?!')[\\s\\S]))?'(?!')/,\n          value: function value(src) {\n            return src.slice(1, -1).replace(/''/g, \"'\");\n          }\n        },\n        argument: {\n          lineBreaks: true,\n          match: /\\{[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*(?:(?![\\t-\\r -\\/:-@\\[-\\^`\\{-~\\x85\\xA1-\\xA7\\xA9\\xAB\\xAC\\xAE\\xB0\\xB1\\xB6\\xBB\\xBF\\xD7\\xF7\\u200E-\\u2029\\u2030-\\u203E\\u2041-\\u2053\\u2055-\\u205E\\u2190-\\u245F\\u2500-\\u2775\\u2794-\\u2BFF\\u2E00-\\u2E7F\\u3001-\\u3003\\u3008-\\u3020\\u3030\\uFD3E\\uFD3F\\uFE45\\uFE46])[\\s\\S])+[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*/,\n          push: 'arg',\n          value: function value(src) {\n            return src.substring(1).trim();\n          }\n        },\n        octothorpe: '#',\n        end: {\n          match: '}',\n          pop: 1\n        },\n        content: {\n          lineBreaks: true,\n          match: /(?:(?![])[\\s\\S])(?:(?![#'\\{\\}])[\\s\\S])*/\n        }\n      },\n      arg: {\n        select: {\n          lineBreaks: true,\n          match: /,[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*(?:plural|select|selectordinal)[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*,[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*/,\n          next: 'select',\n          value: function value(src) {\n            return src.split(',')[1].trim();\n          }\n        },\n        'func-args': {\n          lineBreaks: true,\n          match: /,[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*(?:(?![\\t-\\r -\\/:-@\\[-\\^`\\{-~\\x85\\xA1-\\xA7\\xA9\\xAB\\xAC\\xAE\\xB0\\xB1\\xB6\\xBB\\xBF\\xD7\\xF7\\u200E-\\u2029\\u2030-\\u203E\\u2041-\\u2053\\u2055-\\u205E\\u2190-\\u245F\\u2500-\\u2775\\u2794-\\u2BFF\\u2E00-\\u2E7F\\u3001-\\u3003\\u3008-\\u3020\\u3030\\uFD3E\\uFD3F\\uFE45\\uFE46])[\\s\\S])+[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*,/,\n          next: 'body',\n          value: function value(src) {\n            return src.split(',')[1].trim();\n          }\n        },\n        'func-simple': {\n          lineBreaks: true,\n          match: /,[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*(?:(?![\\t-\\r -\\/:-@\\[-\\^`\\{-~\\x85\\xA1-\\xA7\\xA9\\xAB\\xAC\\xAE\\xB0\\xB1\\xB6\\xBB\\xBF\\xD7\\xF7\\u200E-\\u2029\\u2030-\\u203E\\u2041-\\u2053\\u2055-\\u205E\\u2190-\\u245F\\u2500-\\u2775\\u2794-\\u2BFF\\u2E00-\\u2E7F\\u3001-\\u3003\\u3008-\\u3020\\u3030\\uFD3E\\uFD3F\\uFE45\\uFE46])[\\s\\S])+[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*/,\n          value: function value(src) {\n            return src.substring(1).trim();\n          }\n        },\n        end: {\n          match: '}',\n          pop: 1\n        }\n      },\n      select: {\n        offset: {\n          lineBreaks: true,\n          match: /[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*offset[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*:[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*[0-9]+[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*/,\n          value: function value(src) {\n            return src.split(':')[1].trim();\n          }\n        },\n        case: {\n          lineBreaks: true,\n          match: /[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*(?:=[0-9]+|(?:(?![\\t-\\r -\\/:-@\\[-\\^`\\{-~\\x85\\xA1-\\xA7\\xA9\\xAB\\xAC\\xAE\\xB0\\xB1\\xB6\\xBB\\xBF\\xD7\\xF7\\u200E-\\u2029\\u2030-\\u203E\\u2041-\\u2053\\u2055-\\u205E\\u2190-\\u245F\\u2500-\\u2775\\u2794-\\u2BFF\\u2E00-\\u2E7F\\u3001-\\u3003\\u3008-\\u3020\\u3030\\uFD3E\\uFD3F\\uFE45\\uFE46])[\\s\\S])+)[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*\\{/,\n          push: 'body',\n          value: function value(src) {\n            return src.substring(0, src.indexOf('{')).trim();\n          }\n        },\n        end: {\n          match: /[\\t-\\r \\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF]*\\}/,\n          pop: 1\n        }\n      }\n    };\n    exports.lexer = moo_1.default.states(exports.states);\n  })(lexer);\n\n  /**\n   * An AST parser for ICU MessageFormat strings\n   *\n   * @packageDocumentation\n   * @example\n   * ```\n   * import { parse } from '@messageformat/parser\n   *\n   * parse('So {wow}.')\n   * [ { type: 'content', value: 'So ' },\n   *   { type: 'argument', arg: 'wow' },\n   *   { type: 'content', value: '.' } ]\n   *\n   *\n   * parse('Such { thing }. { count, selectordinal, one {First} two {Second}' +\n   *       '                  few {Third} other {#th} } word.')\n   * [ { type: 'content', value: 'Such ' },\n   *   { type: 'argument', arg: 'thing' },\n   *   { type: 'content', value: '. ' },\n   *   { type: 'selectordinal',\n   *     arg: 'count',\n   *     cases: [\n   *       { key: 'one', tokens: [ { type: 'content', value: 'First' } ] },\n   *       { key: 'two', tokens: [ { type: 'content', value: 'Second' } ] },\n   *       { key: 'few', tokens: [ { type: 'content', value: 'Third' } ] },\n   *       { key: 'other',\n   *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: 'th' } ] }\n   *     ] },\n   *   { type: 'content', value: ' word.' } ]\n   *\n   *\n   * parse('Many{type,select,plural{ numbers}selectordinal{ counting}' +\n   *                          'select{ choices}other{ some {type}}}.')\n   * [ { type: 'content', value: 'Many' },\n   *   { type: 'select',\n   *     arg: 'type',\n   *     cases: [\n   *       { key: 'plural', tokens: [ { type: 'content', value: 'numbers' } ] },\n   *       { key: 'selectordinal', tokens: [ { type: 'content', value: 'counting' } ] },\n   *       { key: 'select', tokens: [ { type: 'content', value: 'choices' } ] },\n   *       { key: 'other',\n   *         tokens: [ { type: 'content', value: 'some ' }, { type: 'argument', arg: 'type' } ] }\n   *     ] },\n   *   { type: 'content', value: '.' } ]\n   *\n   *\n   * parse('{Such compliance')\n   * // ParseError: invalid syntax at line 1 col 7:\n   * //\n   * //  {Such compliance\n   * //        ^\n   *\n   *\n   * const msg = '{words, plural, zero{No words} one{One word} other{# words}}'\n   * parse(msg)\n   * [ { type: 'plural',\n   *     arg: 'words',\n   *     cases: [\n   *       { key: 'zero', tokens: [ { type: 'content', value: 'No words' } ] },\n   *       { key: 'one', tokens: [ { type: 'content', value: 'One word' } ] },\n   *       { key: 'other',\n   *         tokens: [ { type: 'octothorpe' }, { type: 'content', value: ' words' } ] }\n   *     ] } ]\n   *\n   *\n   * parse(msg, { cardinal: [ 'one', 'other' ], ordinal: [ 'one', 'two', 'few', 'other' ] })\n   * // ParseError: The plural case zero is not valid in this locale at line 1 col 17:\n   * //\n   * //   {words, plural, zero{\n   * //                   ^\n   * ```\n   */\n\n  Object.defineProperty(parser, \"__esModule\", {\n    value: true\n  });\n  var parse_1 = parser.parse = parser.ParseError = void 0;\n  var lexer_js_1 = lexer;\n  var getContext = function getContext(lt) {\n    return {\n      offset: lt.offset,\n      line: lt.line,\n      col: lt.col,\n      text: lt.text,\n      lineBreaks: lt.lineBreaks\n    };\n  };\n  var isSelectType = function isSelectType(type) {\n    return type === 'plural' || type === 'select' || type === 'selectordinal';\n  };\n  function strictArgStyleParam(lt, param) {\n    var value = '';\n    var text = '';\n    var _iterator = _createForOfIteratorHelper(param),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var p = _step.value;\n        var pText = p.ctx.text;\n        text += pText;\n        switch (p.type) {\n          case 'content':\n            value += p.value;\n            break;\n          case 'argument':\n          case 'function':\n          case 'octothorpe':\n            value += pText;\n            break;\n          default:\n            throw new ParseError(lt, \"Unsupported part in strict mode function arg style: \".concat(pText));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var c = {\n      type: 'content',\n      value: value.trim(),\n      ctx: Object.assign({}, param[0].ctx, {\n        text: text\n      })\n    };\n    return [c];\n  }\n  var strictArgTypes = ['number', 'date', 'time', 'spellout', 'ordinal', 'duration'];\n  var defaultPluralKeys = ['zero', 'one', 'two', 'few', 'many', 'other'];\n  /**\n   * Thrown by {@link parse} on error\n   *\n   * @public\n   */\n\n  var ParseError = /*#__PURE__*/function (_Error) {\n    _inherits(ParseError, _Error);\n    var _super = _createSuper(ParseError);\n\n    /** @internal */\n    function ParseError(lt, msg) {\n      _classCallCheck(this, ParseError);\n      return _super.call(this, lexer_js_1.lexer.formatError(lt, msg));\n    }\n    return _createClass(ParseError);\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n  parser.ParseError = ParseError;\n  var Parser = /*#__PURE__*/function () {\n    function Parser(src, opt) {\n      _classCallCheck(this, Parser);\n      this.lexer = lexer_js_1.lexer.reset(src);\n      this.cardinalKeys = opt && opt.cardinal || defaultPluralKeys;\n      this.ordinalKeys = opt && opt.ordinal || defaultPluralKeys;\n      this.strict = opt && opt.strict || false;\n    }\n    _createClass(Parser, [{\n      key: \"parse\",\n      value: function parse() {\n        return this.parseBody(false, true);\n      }\n    }, {\n      key: \"checkSelectKey\",\n      value: function checkSelectKey(lt, type, key) {\n        if (key[0] === '=') {\n          if (type === 'select') throw new ParseError(lt, \"The case \".concat(key, \" is not valid with select\"));\n        } else if (type !== 'select') {\n          var keys = type === 'plural' ? this.cardinalKeys : this.ordinalKeys;\n          if (keys.length > 0 && !keys.includes(key)) {\n            var msg = \"The \".concat(type, \" case \").concat(key, \" is not valid in this locale\");\n            throw new ParseError(lt, msg);\n          }\n        }\n      }\n    }, {\n      key: \"parseSelect\",\n      value: function parseSelect(_ref, inPlural, ctx, type) {\n        var arg = _ref.value;\n        var sel = {\n          type: type,\n          arg: arg,\n          cases: [],\n          ctx: ctx\n        };\n        if (type === 'plural' || type === 'selectordinal') inPlural = true;else if (this.strict) inPlural = false;\n        var _iterator2 = _createForOfIteratorHelper(this.lexer),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var lt = _step2.value;\n            switch (lt.type) {\n              case 'offset':\n                if (type === 'select') throw new ParseError(lt, 'Unexpected plural offset for select');\n                if (sel.cases.length > 0) throw new ParseError(lt, 'Plural offset must be set before cases');\n                sel.pluralOffset = Number(lt.value);\n                ctx.text += lt.text;\n                ctx.lineBreaks += lt.lineBreaks;\n                break;\n              case 'case':\n                {\n                  this.checkSelectKey(lt, type, lt.value);\n                  sel.cases.push({\n                    key: lt.value,\n                    tokens: this.parseBody(inPlural),\n                    ctx: getContext(lt)\n                  });\n                  break;\n                }\n              case 'end':\n                return sel;\n\n              /* istanbul ignore next: never happens */\n\n              default:\n                throw new ParseError(lt, \"Unexpected lexer token: \".concat(lt.type));\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n        throw new ParseError(null, 'Unexpected message end');\n      }\n    }, {\n      key: \"parseArgToken\",\n      value: function parseArgToken(lt, inPlural) {\n        var ctx = getContext(lt);\n        var argType = this.lexer.next();\n        if (!argType) throw new ParseError(null, 'Unexpected message end');\n        ctx.text += argType.text;\n        ctx.lineBreaks += argType.lineBreaks;\n        if (this.strict && (argType.type === 'func-simple' || argType.type === 'func-args') && !strictArgTypes.includes(argType.value)) {\n          var msg = \"Invalid strict mode function arg type: \".concat(argType.value);\n          throw new ParseError(lt, msg);\n        }\n        switch (argType.type) {\n          case 'end':\n            return {\n              type: 'argument',\n              arg: lt.value,\n              ctx: ctx\n            };\n          case 'func-simple':\n            {\n              var end = this.lexer.next();\n              if (!end) throw new ParseError(null, 'Unexpected message end');\n              /* istanbul ignore if: never happens */\n\n              if (end.type !== 'end') throw new ParseError(end, \"Unexpected lexer token: \".concat(end.type));\n              ctx.text += end.text;\n              if (isSelectType(argType.value.toLowerCase())) throw new ParseError(argType, \"Invalid type identifier: \".concat(argType.value));\n              return {\n                type: 'function',\n                arg: lt.value,\n                key: argType.value,\n                ctx: ctx\n              };\n            }\n          case 'func-args':\n            {\n              if (isSelectType(argType.value.toLowerCase())) {\n                var _msg = \"Invalid type identifier: \".concat(argType.value);\n                throw new ParseError(argType, _msg);\n              }\n              var param = this.parseBody(this.strict ? false : inPlural);\n              if (this.strict && param.length > 0) param = strictArgStyleParam(lt, param);\n              return {\n                type: 'function',\n                arg: lt.value,\n                key: argType.value,\n                param: param,\n                ctx: ctx\n              };\n            }\n          case 'select':\n            /* istanbul ignore else: never happens */\n            if (isSelectType(argType.value)) return this.parseSelect(lt, inPlural, ctx, argType.value);else throw new ParseError(argType, \"Unexpected select type \".concat(argType.value));\n\n          /* istanbul ignore next: never happens */\n\n          default:\n            throw new ParseError(argType, \"Unexpected lexer token: \".concat(argType.type));\n        }\n      }\n    }, {\n      key: \"parseBody\",\n      value: function parseBody(inPlural, atRoot) {\n        var tokens = [];\n        var content = null;\n        var _iterator3 = _createForOfIteratorHelper(this.lexer),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var lt = _step3.value;\n            if (lt.type === 'argument') {\n              if (content) content = null;\n              tokens.push(this.parseArgToken(lt, inPlural));\n            } else if (lt.type === 'octothorpe' && inPlural) {\n              if (content) content = null;\n              tokens.push({\n                type: 'octothorpe',\n                ctx: getContext(lt)\n              });\n            } else if (lt.type === 'end' && !atRoot) {\n              return tokens;\n            } else {\n              var value = lt.value;\n              if (!inPlural && lt.type === 'quoted' && value[0] === '#') {\n                if (value.includes('{')) {\n                  var errMsg = \"Unsupported escape pattern: \".concat(value);\n                  throw new ParseError(lt, errMsg);\n                }\n                value = lt.text;\n              }\n              if (content) {\n                content.value += value;\n                content.ctx.text += lt.text;\n                content.ctx.lineBreaks += lt.lineBreaks;\n              } else {\n                content = {\n                  type: 'content',\n                  value: value,\n                  ctx: getContext(lt)\n                };\n                tokens.push(content);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        if (atRoot) return tokens;\n        throw new ParseError(null, 'Unexpected message end');\n      }\n    }]);\n    return Parser;\n  }();\n  /**\n   * Parse an input string into an array of tokens\n   *\n   * @public\n   * @remarks\n   * The parser only supports the default `DOUBLE_OPTIONAL`\n   * {@link http://www.icu-project.org/apiref/icu4c/messagepattern_8h.html#af6e0757e0eb81c980b01ee5d68a9978b | apostrophe mode}.\n   */\n\n  function parse(src) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var parser = new Parser(src, options);\n    return parser.parse();\n  }\n  parse_1 = parser.parse = parse;\n\n  /**\n   * A set of utility functions that are called by the compiled Javascript\n   * functions, these are included locally in the output of {@link MessageFormat.compile compile()}.\n   */\n\n  /** @private */\n  function _nf$1(lc) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return _nf$1[lc] || (_nf$1[lc] = new Intl.NumberFormat(lc));\n  }\n  /**\n   * Utility function for `#` in plural rules\n   *\n   * @param lc The current locale\n   * @param value The value to operate on\n   * @param offset An offset, set by the surrounding context\n   * @returns The result of applying the offset to the input value\n   */\n\n  function number(lc, value, offset) {\n    return _nf$1(lc).format(value - offset);\n  }\n  /**\n   * Strict utility function for `#` in plural rules\n   *\n   * Will throw an Error if `value` or `offset` are non-numeric.\n   *\n   * @param lc The current locale\n   * @param value The value to operate on\n   * @param offset An offset, set by the surrounding context\n   * @param name The name of the argument, used for error reporting\n   * @returns The result of applying the offset to the input value\n   */\n\n  function strictNumber(lc, value, offset, name) {\n    var n = value - offset;\n    if (isNaN(n)) throw new Error('`' + name + '` or its offset is not a number');\n    return _nf$1(lc).format(n);\n  }\n  /**\n   * Utility function for `{N, plural|selectordinal, ...}`\n   *\n   * @param value The key to use to find a pluralization rule\n   * @param offset An offset to apply to `value`\n   * @param lcfunc A locale function from `pluralFuncs`\n   * @param data The object from which results are looked up\n   * @param isOrdinal If true, use ordinal rather than cardinal rules\n   * @returns The result of the pluralization\n   */\n\n  function plural(value, offset, lcfunc, data, isOrdinal) {\n    if ({}.hasOwnProperty.call(data, value)) return data[value];\n    if (offset) value -= offset;\n    var key = lcfunc(value, isOrdinal);\n    return key in data ? data[key] : data.other;\n  }\n  /**\n   * Utility function for `{N, select, ...}`\n   *\n   * @param value The key to use to find a selection\n   * @param data The object from which results are looked up\n   * @returns The result of the select statement\n   */\n\n  function select(value, data) {\n    return {}.hasOwnProperty.call(data, value) ? data[value] : data.other;\n  }\n  /**\n   * Checks that all required arguments are set to defined values\n   *\n   * Throws on failure; otherwise returns undefined\n   *\n   * @param keys The required keys\n   * @param data The data object being checked\n   */\n\n  function reqArgs(keys, data) {\n    for (var i = 0; i < keys.length; ++i) {\n      if (!data || data[keys[i]] === undefined) throw new Error(\"Message requires argument '\".concat(keys[i], \"'\"));\n    }\n  }\n  var Runtime = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    _nf: _nf$1,\n    number: number,\n    strictNumber: strictNumber,\n    plural: plural,\n    select: select,\n    reqArgs: reqArgs\n  });\n\n  /**\n   * Represent a date as a short/default/long/full string\n   *\n   * @param value Either a Unix epoch time in milliseconds, or a string value\n   *   representing a date. Parsed with `new Date(value)`\n   *\n   * @example\n   * ```js\n   * var mf = new MessageFormat(['en', 'fi']);\n   *\n   * mf.compile('Today is {T, date}')({ T: Date.now() })\n   * // 'Today is Feb 21, 2016'\n   *\n   * mf.compile('Tänään on {T, date}', 'fi')({ T: Date.now() })\n   * // 'Tänään on 21. helmikuuta 2016'\n   *\n   * mf.compile('Unix time started on {T, date, full}')({ T: 0 })\n   * // 'Unix time started on Thursday, January 1, 1970'\n   *\n   * var cf = mf.compile('{sys} became operational on {d0, date, short}');\n   * cf({ sys: 'HAL 9000', d0: '12 January 1999' })\n   * // 'HAL 9000 became operational on 1/12/1999'\n   * ```\n   */\n  function date(value, lc, size) {\n    var o = {\n      day: 'numeric',\n      month: 'short',\n      year: 'numeric'\n    };\n    /* eslint-disable no-fallthrough */\n\n    switch (size) {\n      case 'full':\n        o.weekday = 'long';\n      case 'long':\n        o.month = 'long';\n        break;\n      case 'short':\n        o.month = 'numeric';\n    }\n    return new Date(value).toLocaleDateString(lc, o);\n  }\n\n  /**\n   * Represent a duration in seconds as a string\n   *\n   * @param value A finite number, or its string representation\n   * @return Includes one or two `:` separators, and matches the pattern\n   *   `hhhh:mm:ss`, possibly with a leading `-` for negative values and a\n   *   trailing `.sss` part for non-integer input\n   *\n   * @example\n   * ```js\n   * var mf = new MessageFormat();\n   *\n   * mf.compile('It has been {D, duration}')({ D: 123 })\n   * // 'It has been 2:03'\n   *\n   * mf.compile('Countdown: {D, duration}')({ D: -151200.42 })\n   * // 'Countdown: -42:00:00.420'\n   * ```\n   */\n  function duration(value) {\n    if (typeof value !== 'number') value = Number(value);\n    if (!isFinite(value)) return String(value);\n    var sign = '';\n    if (value < 0) {\n      sign = '-';\n      value = Math.abs(value);\n    } else {\n      value = Number(value);\n    }\n    var sec = value % 60;\n    var parts = [Math.round(sec) === sec ? sec : sec.toFixed(3)];\n    if (value < 60) {\n      parts.unshift(0); // at least one : is required\n    } else {\n      value = Math.round((value - Number(parts[0])) / 60);\n      parts.unshift(value % 60); // minutes\n\n      if (value >= 60) {\n        value = Math.round((value - Number(parts[0])) / 60);\n        parts.unshift(value); // hours\n      }\n    }\n\n    var first = parts.shift();\n    return sign + first + ':' + parts.map(function (n) {\n      return n < 10 ? '0' + String(n) : String(n);\n    }).join(':');\n  }\n\n  /**\n   * Represent a number as an integer, percent or currency value\n   *\n   * Available in MessageFormat strings as `{VAR, number, integer|percent|currency}`.\n   * Internally, calls Intl.NumberFormat with appropriate parameters. `currency` will\n   * default to USD; to change, set `MessageFormat#currency` to the appropriate\n   * three-letter currency code, or use the `currency:EUR` form of the argument.\n   *\n   * @example\n   * ```js\n   * var mf = new MessageFormat('en', { currency: 'EUR'});\n   *\n   * mf.compile('{N} is almost {N, number, integer}')({ N: 3.14 })\n   * // '3.14 is almost 3'\n   *\n   * mf.compile('{P, number, percent} complete')({ P: 0.99 })\n   * // '99% complete'\n   *\n   * mf.compile('The total is {V, number, currency}.')({ V: 5.5 })\n   * // 'The total is €5.50.'\n   *\n   * mf.compile('The total is {V, number, currency:GBP}.')({ V: 5.5 })\n   * // 'The total is £5.50.'\n   * ```\n   */\n  var _nf = {};\n  function nf(lc, opt) {\n    var key = String(lc) + JSON.stringify(opt);\n    if (!_nf[key]) _nf[key] = new Intl.NumberFormat(lc, opt);\n    return _nf[key];\n  }\n  function numberFmt(value, lc, arg, defaultCurrency) {\n    var _a = arg && arg.split(':') || [],\n      type = _a[0],\n      currency = _a[1];\n    var opt = {\n      integer: {\n        maximumFractionDigits: 0\n      },\n      percent: {\n        style: 'percent'\n      },\n      currency: {\n        style: 'currency',\n        currency: currency && currency.trim() || defaultCurrency,\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n      }\n    };\n    return nf(lc, opt[type] || {}).format(value);\n  }\n  var numberCurrency = function numberCurrency(value, lc, arg) {\n    return nf(lc, {\n      style: 'currency',\n      currency: arg,\n      minimumFractionDigits: 2,\n      maximumFractionDigits: 2\n    }).format(value);\n  };\n  var numberInteger = function numberInteger(value, lc) {\n    return nf(lc, {\n      maximumFractionDigits: 0\n    }).format(value);\n  };\n  var numberPercent = function numberPercent(value, lc) {\n    return nf(lc, {\n      style: 'percent'\n    }).format(value);\n  };\n\n  /**\n   * Represent a time as a short/default/long string\n   *\n   * @param value Either a Unix epoch time in milliseconds, or a string value\n   *   representing a date. Parsed with `new Date(value)`\n   *\n   * @example\n   * ```js\n   * var mf = new MessageFormat(['en', 'fi']);\n   *\n   * mf.compile('The time is now {T, time}')({ T: Date.now() })\n   * // 'The time is now 11:26:35 PM'\n   *\n   * mf.compile('Kello on nyt {T, time}', 'fi')({ T: Date.now() })\n   * // 'Kello on nyt 23.26.35'\n   *\n   * var cf = mf.compile('The Eagle landed at {T, time, full} on {T, date, full}');\n   * cf({ T: '1969-07-20 20:17:40 UTC' })\n   * // 'The Eagle landed at 10:17:40 PM GMT+2 on Sunday, July 20, 1969'\n   * ```\n   */\n  function time(value, lc, size) {\n    var o = {\n      second: 'numeric',\n      minute: 'numeric',\n      hour: 'numeric'\n    };\n    /* eslint-disable no-fallthrough */\n\n    switch (size) {\n      case 'full':\n      case 'long':\n        o.timeZoneName = 'short';\n        break;\n      case 'short':\n        delete o.second;\n    }\n    return new Date(value).toLocaleTimeString(lc, o);\n  }\n  var Formatters = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    date: date,\n    duration: duration,\n    numberCurrency: numberCurrency,\n    numberFmt: numberFmt,\n    numberInteger: numberInteger,\n    numberPercent: numberPercent,\n    time: time\n  });\n  var ES3 = {\n    break: true,\n    continue: true,\n    delete: true,\n    else: true,\n    for: true,\n    function: true,\n    if: true,\n    in: true,\n    new: true,\n    return: true,\n    this: true,\n    typeof: true,\n    var: true,\n    void: true,\n    while: true,\n    with: true,\n    case: true,\n    catch: true,\n    default: true,\n    do: true,\n    finally: true,\n    instanceof: true,\n    switch: true,\n    throw: true,\n    try: true\n  };\n  var ESnext = {\n    // in addition to reservedES3\n    await: true,\n    debugger: true,\n    class: true,\n    enum: true,\n    extends: true,\n    super: true,\n    const: true,\n    export: true,\n    import: true,\n    null: true,\n    true: true,\n    false: true,\n    implements: true,\n    let: true,\n    private: true,\n    public: true,\n    yield: true,\n    interface: true,\n    package: true,\n    protected: true,\n    static: true\n  };\n  var reserved = {\n    ES3: ES3,\n    ESnext: ESnext\n  };\n  var reserved$1 = reserved;\n  function hashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; ++i) {\n      var char = str.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return hash;\n  }\n  function identifier(key, unique) {\n    if (unique) key += ' ' + hashCode(key).toString(36);\n    var id = key.trim().replace(/\\W+/g, '_');\n    return reserved$1.ES3[id] || reserved$1.ESnext[id] || /^\\d/.test(id) ? '_' + id : id;\n  }\n  function property(obj, key) {\n    if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key) && !reserved$1.ES3[key]) {\n      return obj ? obj + '.' + key : key;\n    } else {\n      var jkey = JSON.stringify(key);\n      return obj ? obj + '[' + jkey + ']' : jkey;\n    }\n  }\n  var rtlLanguages = ['ar', 'ckb', 'fa', 'he', 'ks($|[^bfh])', 'lrc', 'mzn', 'pa-Arab', 'ps', 'ug', 'ur', 'uz-Arab', 'yi'];\n  var rtlRegExp = new RegExp('^' + rtlLanguages.join('|^'));\n  function biDiMarkText(text, locale) {\n    var isLocaleRTL = rtlRegExp.test(locale);\n    var mark = JSON.stringify(isLocaleRTL ? '\\u200F' : '\\u200E');\n    return \"\".concat(mark, \" + \").concat(text, \" + \").concat(mark);\n  }\n  var RUNTIME_MODULE = '@messageformat/runtime';\n  var CARDINAL_MODULE = '@messageformat/runtime/lib/cardinals';\n  var PLURAL_MODULE = '@messageformat/runtime/lib/plurals';\n  var FORMATTER_MODULE = '@messageformat/runtime/lib/formatters';\n  var Compiler = function () {\n    function Compiler(options) {\n      this.arguments = [];\n      this.runtime = {};\n      this.options = options;\n    }\n    Compiler.prototype.compile = function (src, plural, plurals) {\n      var e_1, _a;\n      var _this = this;\n      if (typeof src === 'object') {\n        var result = {};\n        try {\n          for (var _b = __values(Object.keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var key = _c.value;\n            var pl = plurals && plurals[key] || plural;\n            result[key] = this.compile(src[key], pl, plurals);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n        return result;\n      }\n      this.plural = plural;\n      var parserOptions = {\n        cardinal: plural.cardinals,\n        ordinal: plural.ordinals,\n        strict: this.options.strict\n      };\n      this.arguments = [];\n      var r = parse_1(src, parserOptions).map(function (token) {\n        return _this.token(token, null);\n      });\n      var hasArgs = this.arguments.length > 0;\n      var res = this.concatenate(r, true);\n      if (this.options.requireAllArguments && hasArgs) {\n        this.setRuntimeFn('reqArgs');\n        var reqArgs = JSON.stringify(this.arguments);\n        return \"(d) => { reqArgs(\".concat(reqArgs, \", d); return \").concat(res, \"; }\");\n      }\n      return \"(\".concat(hasArgs ? 'd' : '', \") => \").concat(res);\n    };\n    Compiler.prototype.cases = function (token, pluralToken) {\n      var _this = this;\n      var needOther = true;\n      var r = token.cases.map(function (_a) {\n        var key = _a.key,\n          tokens = _a.tokens;\n        if (key === 'other') needOther = false;\n        var s = tokens.map(function (tok) {\n          return _this.token(tok, pluralToken);\n        });\n        return \"\".concat(property(null, key.replace(/^=/, '')), \": \").concat(_this.concatenate(s, false));\n      });\n      if (needOther) {\n        var type = token.type;\n        var _a = this.plural,\n          cardinals = _a.cardinals,\n          ordinals = _a.ordinals;\n        if (type === 'select' || type === 'plural' && cardinals.includes('other') || type === 'selectordinal' && ordinals.includes('other')) throw new Error(\"No 'other' form found in \".concat(JSON.stringify(token)));\n      }\n      return \"{ \".concat(r.join(', '), \" }\");\n    };\n    Compiler.prototype.concatenate = function (tokens, root) {\n      var asValues = this.options.returnType === 'values';\n      return asValues && (root || tokens.length > 1) ? '[' + tokens.join(', ') + ']' : tokens.join(' + ') || '\"\"';\n    };\n    Compiler.prototype.token = function (token, pluralToken) {\n      if (token.type === 'content') return JSON.stringify(token.value);\n      var _a = this.plural,\n        id = _a.id,\n        lc = _a.lc;\n      var args, fn;\n      if ('arg' in token) {\n        this.arguments.push(token.arg);\n        args = [property('d', token.arg)];\n      } else args = [];\n      switch (token.type) {\n        case 'argument':\n          return this.options.biDiSupport ? biDiMarkText(String(args[0]), lc) : String(args[0]);\n        case 'select':\n          fn = 'select';\n          if (pluralToken && this.options.strict) pluralToken = null;\n          args.push(this.cases(token, pluralToken));\n          this.setRuntimeFn('select');\n          break;\n        case 'selectordinal':\n          fn = 'plural';\n          args.push(token.pluralOffset || 0, id, this.cases(token, token), 1);\n          this.setLocale(id, true);\n          this.setRuntimeFn('plural');\n          break;\n        case 'plural':\n          fn = 'plural';\n          args.push(token.pluralOffset || 0, id, this.cases(token, token));\n          this.setLocale(id, false);\n          this.setRuntimeFn('plural');\n          break;\n        case 'function':\n          if (!this.options.customFormatters[token.key]) {\n            if (token.key === 'date') {\n              fn = this.setDateFormatter(token, args, pluralToken);\n              break;\n            } else if (token.key === 'number') {\n              fn = this.setNumberFormatter(token, args, pluralToken);\n              break;\n            }\n          }\n          args.push(JSON.stringify(this.plural.locale));\n          if (token.param) {\n            if (pluralToken && this.options.strict) pluralToken = null;\n            var arg = this.getFormatterArg(token, pluralToken);\n            if (arg) args.push(arg);\n          }\n          fn = token.key;\n          this.setFormatter(fn);\n          break;\n        case 'octothorpe':\n          if (!pluralToken) return '\"#\"';\n          args = [JSON.stringify(this.plural.locale), property('d', pluralToken.arg), pluralToken.pluralOffset || 0];\n          if (this.options.strict) {\n            fn = 'strictNumber';\n            args.push(JSON.stringify(pluralToken.arg));\n            this.setRuntimeFn('strictNumber');\n          } else {\n            fn = 'number';\n            this.setRuntimeFn('number');\n          }\n          break;\n      }\n      if (!fn) throw new Error('Parser error for token ' + JSON.stringify(token));\n      return \"\".concat(fn, \"(\").concat(args.join(', '), \")\");\n    };\n    Compiler.prototype.runtimeIncludes = function (key, type) {\n      if (identifier(key) !== key) throw new SyntaxError(\"Reserved word used as \".concat(type, \" identifier: \").concat(key));\n      var prev = this.runtime[key];\n      if (!prev || prev.type === type) return prev;\n      throw new TypeError(\"Cannot override \".concat(prev.type, \" runtime function as \").concat(type, \": \").concat(key));\n    };\n    Compiler.prototype.setLocale = function (key, ord) {\n      var prev = this.runtimeIncludes(key, 'locale');\n      var _a = this.plural,\n        getCardinal = _a.getCardinal,\n        getPlural = _a.getPlural,\n        isDefault = _a.isDefault;\n      var pf, module, toString;\n      if (!ord && isDefault && getCardinal) {\n        if (prev) return;\n        pf = function (n) {\n          return getCardinal(n);\n        };\n        module = CARDINAL_MODULE;\n        toString = function () {\n          return String(getCardinal);\n        };\n      } else {\n        if (prev && (!isDefault || prev.module === PLURAL_MODULE)) return;\n        pf = function (n, ord) {\n          return getPlural(n, ord);\n        };\n        module = isDefault ? PLURAL_MODULE : getPlural.module || null;\n        toString = function () {\n          return String(getPlural);\n        };\n      }\n      this.runtime[key] = Object.assign(pf, {\n        id: key,\n        module: module,\n        toString: toString,\n        type: 'locale'\n      });\n    };\n    Compiler.prototype.setRuntimeFn = function (key) {\n      if (this.runtimeIncludes(key, 'runtime')) return;\n      this.runtime[key] = Object.assign(Runtime[key], {\n        id: key,\n        module: RUNTIME_MODULE,\n        type: 'runtime'\n      });\n    };\n    Compiler.prototype.getFormatterArg = function (_a, pluralToken) {\n      var e_2, _b, e_3, _c;\n      var _this = this;\n      var key = _a.key,\n        param = _a.param;\n      var fmt = this.options.customFormatters[key] || isFormatterKey(key) && Formatters[key];\n      if (!fmt || !param) return null;\n      var argShape = 'arg' in fmt && fmt.arg || 'string';\n      if (argShape === 'options') {\n        var value = '';\n        try {\n          for (var param_1 = __values(param), param_1_1 = param_1.next(); !param_1_1.done; param_1_1 = param_1.next()) {\n            var tok = param_1_1.value;\n            if (tok.type === 'content') value += tok.value;else throw new SyntaxError(\"Expected literal options for \".concat(key, \" formatter\"));\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (param_1_1 && !param_1_1.done && (_b = param_1.return)) _b.call(param_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n        var options = {};\n        try {\n          for (var _d = __values(value.split(',')), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var pair = _e.value;\n            var keyEnd = pair.indexOf(':');\n            if (keyEnd === -1) options[pair.trim()] = null;else {\n              var k = pair.substring(0, keyEnd).trim();\n              var v = pair.substring(keyEnd + 1).trim();\n              if (v === 'true') options[k] = true;else if (v === 'false') options[k] = false;else if (v === 'null') options[k] = null;else {\n                var n = Number(v);\n                options[k] = Number.isFinite(n) ? n : v;\n              }\n            }\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n        return JSON.stringify(options);\n      } else {\n        var parts = param.map(function (tok) {\n          return _this.token(tok, pluralToken);\n        });\n        if (argShape === 'raw') return \"[\".concat(parts.join(', '), \"]\");\n        var s = parts.join(' + ');\n        return s ? \"(\".concat(s, \").trim()\") : '\"\"';\n      }\n    };\n    Compiler.prototype.setFormatter = function (key) {\n      if (this.runtimeIncludes(key, 'formatter')) return;\n      var cf = this.options.customFormatters[key];\n      if (cf) {\n        if (typeof cf === 'function') cf = {\n          formatter: cf\n        };\n        this.runtime[key] = Object.assign(cf.formatter, {\n          type: 'formatter'\n        }, 'module' in cf && cf.module && cf.id ? {\n          id: identifier(cf.id),\n          module: cf.module\n        } : {\n          id: null,\n          module: null\n        });\n      } else if (isFormatterKey(key)) {\n        this.runtime[key] = Object.assign(Formatters[key], {\n          type: 'formatter'\n        }, {\n          id: key,\n          module: FORMATTER_MODULE\n        });\n      } else {\n        throw new Error(\"Formatting function not found: \".concat(key));\n      }\n    };\n    Compiler.prototype.setDateFormatter = function (_a, args, plural) {\n      var _this = this;\n      var param = _a.param;\n      var locale = this.plural.locale;\n      var argStyle = param && param.length === 1 && param[0];\n      if (argStyle && argStyle.type === 'content' && /^\\s*::/.test(argStyle.value)) {\n        var argSkeletonText_1 = argStyle.value.trim().substr(2);\n        var key = identifier(\"date_\".concat(locale, \"_\").concat(argSkeletonText_1), true);\n        if (!this.runtimeIncludes(key, 'formatter')) {\n          var fmt = getDateFormatter(locale, argSkeletonText_1);\n          this.runtime[key] = Object.assign(fmt, {\n            id: key,\n            module: null,\n            toString: function () {\n              return getDateFormatterSource(locale, argSkeletonText_1);\n            },\n            type: 'formatter'\n          });\n        }\n        return key;\n      }\n      args.push(JSON.stringify(locale));\n      if (param && param.length > 0) {\n        if (plural && this.options.strict) plural = null;\n        var s = param.map(function (tok) {\n          return _this.token(tok, plural);\n        });\n        args.push('(' + (s.join(' + ') || '\"\"') + ').trim()');\n      }\n      this.setFormatter('date');\n      return 'date';\n    };\n    Compiler.prototype.setNumberFormatter = function (_a, args, plural) {\n      var _this = this;\n      var param = _a.param;\n      var locale = this.plural.locale;\n      if (!param || param.length === 0) {\n        args.unshift(JSON.stringify(locale));\n        args.push('0');\n        this.setRuntimeFn('number');\n        return 'number';\n      }\n      args.push(JSON.stringify(locale));\n      if (param.length === 1 && param[0].type === 'content') {\n        var fmtArg_1 = param[0].value.trim();\n        switch (fmtArg_1) {\n          case 'currency':\n            args.push(JSON.stringify(this.options.currency));\n            this.setFormatter('numberCurrency');\n            return 'numberCurrency';\n          case 'integer':\n            this.setFormatter('numberInteger');\n            return 'numberInteger';\n          case 'percent':\n            this.setFormatter('numberPercent');\n            return 'numberPercent';\n        }\n        var cm = fmtArg_1.match(/^currency:([A-Z]+)$/);\n        if (cm) {\n          args.push(JSON.stringify(cm[1]));\n          this.setFormatter('numberCurrency');\n          return 'numberCurrency';\n        }\n        var key = identifier(\"number_\".concat(locale, \"_\").concat(fmtArg_1), true);\n        if (!this.runtimeIncludes(key, 'formatter')) {\n          var currency_1 = this.options.currency;\n          var fmt = getNumberFormatter(locale, fmtArg_1, currency_1);\n          this.runtime[key] = Object.assign(fmt, {\n            id: null,\n            module: null,\n            toString: function () {\n              return getNumberFormatterSource(locale, fmtArg_1, currency_1);\n            },\n            type: 'formatter'\n          });\n        }\n        return key;\n      }\n      if (plural && this.options.strict) plural = null;\n      var s = param.map(function (tok) {\n        return _this.token(tok, plural);\n      });\n      args.push('(' + (s.join(' + ') || '\"\"') + ').trim()');\n      args.push(JSON.stringify(this.options.currency));\n      this.setFormatter('numberFmt');\n      return 'numberFmt';\n    };\n    return Compiler;\n  }();\n  function isFormatterKey(key) {\n    return key in Formatters;\n  }\n  var a$2 = function a(n) {\n    return n == 1 ? 'one' : 'other';\n  };\n  var b$2 = function b(n) {\n    return n == 0 || n == 1 ? 'one' : 'other';\n  };\n  var c$2 = function c(n) {\n    return n >= 0 && n <= 1 ? 'one' : 'other';\n  };\n  var d$2 = function d(n) {\n    var s = String(n).split('.'),\n      v0 = !s[1];\n    return n == 1 && v0 ? 'one' : 'other';\n  };\n  var e$2 = function e(n) {\n    return 'other';\n  };\n  var f$2 = function f(n) {\n    return n == 1 ? 'one' : n == 2 ? 'two' : 'other';\n  };\n  var af$2 = a$2;\n  var ak$2 = b$2;\n  var am$2 = c$2;\n  var an$2 = a$2;\n  var ar$2 = function ar(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    return n == 0 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n100 >= 3 && n100 <= 10 ? 'few' : n100 >= 11 && n100 <= 99 ? 'many' : 'other';\n  };\n  var ars$2 = function ars(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    return n == 0 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n100 >= 3 && n100 <= 10 ? 'few' : n100 >= 11 && n100 <= 99 ? 'many' : 'other';\n  };\n  var as$2 = c$2;\n  var asa$2 = a$2;\n  var ast$2 = d$2;\n  var az$2 = a$2;\n  var bal$2 = a$2;\n  var be$2 = function be(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2);\n    return n10 == 1 && n100 != 11 ? 'one' : n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ? 'few' : t0 && n10 == 0 || n10 >= 5 && n10 <= 9 || n100 >= 11 && n100 <= 14 ? 'many' : 'other';\n  };\n  var bem$2 = a$2;\n  var bez$2 = a$2;\n  var bg$2 = a$2;\n  var bho$2 = b$2;\n  var bm$2 = e$2;\n  var bn$2 = c$2;\n  var bo$2 = e$2;\n  var br$2 = function br(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2),\n      n1000000 = t0 && s[0].slice(-6);\n    return n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91 ? 'one' : n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92 ? 'two' : (n10 == 3 || n10 == 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99) ? 'few' : n != 0 && t0 && n1000000 == 0 ? 'many' : 'other';\n  };\n  var brx$2 = a$2;\n  var bs$2 = function bs(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';\n  };\n  var ca$2 = d$2;\n  var ce$2 = a$2;\n  var ceb$2 = function ceb(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      f10 = f.slice(-1);\n    return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? 'one' : 'other';\n  };\n  var cgg$2 = a$2;\n  var chr$2 = a$2;\n  var ckb$2 = a$2;\n  var cs$2 = function cs(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1];\n    return n == 1 && v0 ? 'one' : i >= 2 && i <= 4 && v0 ? 'few' : !v0 ? 'many' : 'other';\n  };\n  var cy$2 = function cy(n) {\n    return n == 0 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n == 3 ? 'few' : n == 6 ? 'many' : 'other';\n  };\n  var da$2 = function da(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      t0 = Number(s[0]) == n;\n    return n == 1 || !t0 && (i == 0 || i == 1) ? 'one' : 'other';\n  };\n  var de$2 = d$2;\n  var doi$2 = c$2;\n  var dsb$2 = function dsb(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i100 = i.slice(-2),\n      f100 = f.slice(-2);\n    return v0 && i100 == 1 || f100 == 1 ? 'one' : v0 && i100 == 2 || f100 == 2 ? 'two' : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? 'few' : 'other';\n  };\n  var dv$2 = a$2;\n  var dz$2 = e$2;\n  var ee$2 = a$2;\n  var el$2 = a$2;\n  var en$2 = d$2;\n  var eo$2 = a$2;\n  var es$2 = function es(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    return n == 1 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var et$2 = d$2;\n  var eu$2 = a$2;\n  var fa$2 = c$2;\n  var ff$2 = function ff(n) {\n    return n >= 0 && n < 2 ? 'one' : 'other';\n  };\n  var fi$2 = d$2;\n  var fil$2 = function fil(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      f10 = f.slice(-1);\n    return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? 'one' : 'other';\n  };\n  var fo$2 = a$2;\n  var fr$2 = function fr(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    return n >= 0 && n < 2 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var fur$2 = a$2;\n  var fy$2 = d$2;\n  var ga$2 = function ga(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    return n == 1 ? 'one' : n == 2 ? 'two' : t0 && n >= 3 && n <= 6 ? 'few' : t0 && n >= 7 && n <= 10 ? 'many' : 'other';\n  };\n  var gd$2 = function gd(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    return n == 1 || n == 11 ? 'one' : n == 2 || n == 12 ? 'two' : t0 && n >= 3 && n <= 10 || t0 && n >= 13 && n <= 19 ? 'few' : 'other';\n  };\n  var gl$2 = d$2;\n  var gsw$2 = a$2;\n  var gu$2 = c$2;\n  var guw$2 = b$2;\n  var gv$2 = function gv(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    return v0 && i10 == 1 ? 'one' : v0 && i10 == 2 ? 'two' : v0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60 || i100 == 80) ? 'few' : !v0 ? 'many' : 'other';\n  };\n  var ha$2 = a$2;\n  var haw$2 = a$2;\n  var he$2 = function he(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1);\n    return n == 1 && v0 ? 'one' : i == 2 && v0 ? 'two' : v0 && (n < 0 || n > 10) && t0 && n10 == 0 ? 'many' : 'other';\n  };\n  var hi$2 = c$2;\n  var hnj$2 = e$2;\n  var hr$2 = function hr(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';\n  };\n  var hsb$2 = function hsb(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i100 = i.slice(-2),\n      f100 = f.slice(-2);\n    return v0 && i100 == 1 || f100 == 1 ? 'one' : v0 && i100 == 2 || f100 == 2 ? 'two' : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? 'few' : 'other';\n  };\n  var hu$2 = a$2;\n  var hy$2 = function hy(n) {\n    return n >= 0 && n < 2 ? 'one' : 'other';\n  };\n  var ia$2 = d$2;\n  var id$2 = e$2;\n  var ig$2 = e$2;\n  var ii$2 = e$2;\n  var io$2 = d$2;\n  var is$2 = function is(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      t0 = Number(s[0]) == n,\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    return t0 && i10 == 1 && i100 != 11 || !t0 ? 'one' : 'other';\n  };\n  var it$2 = function it(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    return n == 1 && v0 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var iu$2 = f$2;\n  var ja$2 = e$2;\n  var jbo$2 = e$2;\n  var jgo$2 = a$2;\n  var jmc$2 = a$2;\n  var jv$2 = e$2;\n  var jw$2 = e$2;\n  var ka$2 = a$2;\n  var kab$2 = function kab(n) {\n    return n >= 0 && n < 2 ? 'one' : 'other';\n  };\n  var kaj$2 = a$2;\n  var kcg$2 = a$2;\n  var kde$2 = e$2;\n  var kea$2 = e$2;\n  var kk$2 = a$2;\n  var kkj$2 = a$2;\n  var kl$2 = a$2;\n  var km$2 = e$2;\n  var kn$2 = c$2;\n  var ko$2 = e$2;\n  var ks$2 = a$2;\n  var ksb$2 = a$2;\n  var ksh$2 = function ksh(n) {\n    return n == 0 ? 'zero' : n == 1 ? 'one' : 'other';\n  };\n  var ku$2 = a$2;\n  var kw$2 = function kw(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2),\n      n1000 = t0 && s[0].slice(-3),\n      n100000 = t0 && s[0].slice(-5),\n      n1000000 = t0 && s[0].slice(-6);\n    return n == 0 ? 'zero' : n == 1 ? 'one' : n100 == 2 || n100 == 22 || n100 == 42 || n100 == 62 || n100 == 82 || t0 && n1000 == 0 && (n100000 >= 1000 && n100000 <= 20000 || n100000 == 40000 || n100000 == 60000 || n100000 == 80000) || n != 0 && n1000000 == 100000 ? 'two' : n100 == 3 || n100 == 23 || n100 == 43 || n100 == 63 || n100 == 83 ? 'few' : n != 1 && (n100 == 1 || n100 == 21 || n100 == 41 || n100 == 61 || n100 == 81) ? 'many' : 'other';\n  };\n  var ky$2 = a$2;\n  var lag$2 = function lag(n) {\n    var s = String(n).split('.'),\n      i = s[0];\n    return n == 0 ? 'zero' : (i == 0 || i == 1) && n != 0 ? 'one' : 'other';\n  };\n  var lb$2 = a$2;\n  var lg$2 = a$2;\n  var lij$2 = d$2;\n  var lkt$2 = e$2;\n  var ln$2 = b$2;\n  var lo$2 = e$2;\n  var lt$2 = function lt(n) {\n    var s = String(n).split('.'),\n      f = s[1] || '',\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2);\n    return n10 == 1 && (n100 < 11 || n100 > 19) ? 'one' : n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) ? 'few' : f != 0 ? 'many' : 'other';\n  };\n  var lv$2 = function lv(n) {\n    var s = String(n).split('.'),\n      f = s[1] || '',\n      v = f.length,\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2),\n      f100 = f.slice(-2),\n      f10 = f.slice(-1);\n    return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? 'zero' : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? 'one' : 'other';\n  };\n  var mas$2 = a$2;\n  var mg$2 = b$2;\n  var mgo$2 = a$2;\n  var mk$2 = function mk(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : 'other';\n  };\n  var ml$2 = a$2;\n  var mn$2 = a$2;\n  var mo$2 = function mo(n) {\n    var s = String(n).split('.'),\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    return n == 1 && v0 ? 'one' : !v0 || n == 0 || n100 >= 2 && n100 <= 19 ? 'few' : 'other';\n  };\n  var mr$2 = a$2;\n  var ms$2 = e$2;\n  var mt$2 = function mt(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    return n == 1 ? 'one' : n == 0 || n100 >= 2 && n100 <= 10 ? 'few' : n100 >= 11 && n100 <= 19 ? 'many' : 'other';\n  };\n  var my$2 = e$2;\n  var nah$2 = a$2;\n  var naq$2 = f$2;\n  var nb$2 = a$2;\n  var nd$2 = a$2;\n  var ne$2 = a$2;\n  var nl$2 = d$2;\n  var nn$2 = a$2;\n  var nnh$2 = a$2;\n  var no$2 = a$2;\n  var nqo$2 = e$2;\n  var nr$2 = a$2;\n  var nso$2 = b$2;\n  var ny$2 = a$2;\n  var nyn$2 = a$2;\n  var om$2 = a$2;\n  var or$2 = a$2;\n  var os$2 = a$2;\n  var osa$2 = e$2;\n  var pa$2 = b$2;\n  var pap$2 = a$2;\n  var pcm$2 = c$2;\n  var pl$2 = function pl(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    return n == 1 && v0 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? 'few' : v0 && i != 1 && (i10 == 0 || i10 == 1) || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 12 && i100 <= 14 ? 'many' : 'other';\n  };\n  var prg$2 = function prg(n) {\n    var s = String(n).split('.'),\n      f = s[1] || '',\n      v = f.length,\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2),\n      f100 = f.slice(-2),\n      f10 = f.slice(-1);\n    return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? 'zero' : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? 'one' : 'other';\n  };\n  var ps$2 = a$2;\n  var pt$2 = function pt(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    return i == 0 || i == 1 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var pt_PT$2 = function pt_PT(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    return n == 1 && v0 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var rm$2 = a$2;\n  var ro$2 = function ro(n) {\n    var s = String(n).split('.'),\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    return n == 1 && v0 ? 'one' : !v0 || n == 0 || n100 >= 2 && n100 <= 19 ? 'few' : 'other';\n  };\n  var rof$2 = a$2;\n  var ru$2 = function ru(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    return v0 && i10 == 1 && i100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? 'few' : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? 'many' : 'other';\n  };\n  var rwk$2 = a$2;\n  var sah$2 = e$2;\n  var saq$2 = a$2;\n  var sat$2 = f$2;\n  var sc$2 = d$2;\n  var scn$2 = d$2;\n  var sd$2 = a$2;\n  var sdh$2 = a$2;\n  var se$2 = f$2;\n  var seh$2 = a$2;\n  var ses$2 = e$2;\n  var sg$2 = e$2;\n  var sh$2 = function sh(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';\n  };\n  var shi$2 = function shi(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    return n >= 0 && n <= 1 ? 'one' : t0 && n >= 2 && n <= 10 ? 'few' : 'other';\n  };\n  var si$2 = function si(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '';\n    return n == 0 || n == 1 || i == 0 && f == 1 ? 'one' : 'other';\n  };\n  var sk$2 = function sk(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1];\n    return n == 1 && v0 ? 'one' : i >= 2 && i <= 4 && v0 ? 'few' : !v0 ? 'many' : 'other';\n  };\n  var sl$2 = function sl(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i100 = i.slice(-2);\n    return v0 && i100 == 1 ? 'one' : v0 && i100 == 2 ? 'two' : v0 && (i100 == 3 || i100 == 4) || !v0 ? 'few' : 'other';\n  };\n  var sma$2 = f$2;\n  var smi$2 = f$2;\n  var smj$2 = f$2;\n  var smn$2 = f$2;\n  var sms$2 = f$2;\n  var sn$2 = a$2;\n  var so$2 = a$2;\n  var sq$2 = a$2;\n  var sr$2 = function sr(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';\n  };\n  var ss$2 = a$2;\n  var ssy$2 = a$2;\n  var st$2 = a$2;\n  var su$2 = e$2;\n  var sv$2 = d$2;\n  var sw$2 = d$2;\n  var syr$2 = a$2;\n  var ta$2 = a$2;\n  var te$2 = a$2;\n  var teo$2 = a$2;\n  var th$2 = e$2;\n  var ti$2 = b$2;\n  var tig$2 = a$2;\n  var tk$2 = a$2;\n  var tl$2 = function tl(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      f10 = f.slice(-1);\n    return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? 'one' : 'other';\n  };\n  var tn$2 = a$2;\n  var to$2 = e$2;\n  var tpi$2 = e$2;\n  var tr$2 = a$2;\n  var ts$2 = a$2;\n  var tzm$2 = function tzm(n) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    return n == 0 || n == 1 || t0 && n >= 11 && n <= 99 ? 'one' : 'other';\n  };\n  var ug$2 = a$2;\n  var uk$2 = function uk(n) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    return v0 && i10 == 1 && i100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? 'few' : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? 'many' : 'other';\n  };\n  var und$2 = e$2;\n  var ur$2 = d$2;\n  var uz$2 = a$2;\n  var ve$2 = a$2;\n  var vi$2 = e$2;\n  var vo$2 = a$2;\n  var vun$2 = a$2;\n  var wa$2 = b$2;\n  var wae$2 = a$2;\n  var wo$2 = e$2;\n  var xh$2 = a$2;\n  var xog$2 = a$2;\n  var yi$2 = d$2;\n  var yo$2 = e$2;\n  var yue$2 = e$2;\n  var zh$2 = e$2;\n  var zu$2 = c$2;\n  var Cardinals = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    af: af$2,\n    ak: ak$2,\n    am: am$2,\n    an: an$2,\n    ar: ar$2,\n    ars: ars$2,\n    as: as$2,\n    asa: asa$2,\n    ast: ast$2,\n    az: az$2,\n    bal: bal$2,\n    be: be$2,\n    bem: bem$2,\n    bez: bez$2,\n    bg: bg$2,\n    bho: bho$2,\n    bm: bm$2,\n    bn: bn$2,\n    bo: bo$2,\n    br: br$2,\n    brx: brx$2,\n    bs: bs$2,\n    ca: ca$2,\n    ce: ce$2,\n    ceb: ceb$2,\n    cgg: cgg$2,\n    chr: chr$2,\n    ckb: ckb$2,\n    cs: cs$2,\n    cy: cy$2,\n    da: da$2,\n    de: de$2,\n    doi: doi$2,\n    dsb: dsb$2,\n    dv: dv$2,\n    dz: dz$2,\n    ee: ee$2,\n    el: el$2,\n    en: en$2,\n    eo: eo$2,\n    es: es$2,\n    et: et$2,\n    eu: eu$2,\n    fa: fa$2,\n    ff: ff$2,\n    fi: fi$2,\n    fil: fil$2,\n    fo: fo$2,\n    fr: fr$2,\n    fur: fur$2,\n    fy: fy$2,\n    ga: ga$2,\n    gd: gd$2,\n    gl: gl$2,\n    gsw: gsw$2,\n    gu: gu$2,\n    guw: guw$2,\n    gv: gv$2,\n    ha: ha$2,\n    haw: haw$2,\n    he: he$2,\n    hi: hi$2,\n    hnj: hnj$2,\n    hr: hr$2,\n    hsb: hsb$2,\n    hu: hu$2,\n    hy: hy$2,\n    ia: ia$2,\n    id: id$2,\n    ig: ig$2,\n    ii: ii$2,\n    io: io$2,\n    is: is$2,\n    it: it$2,\n    iu: iu$2,\n    ja: ja$2,\n    jbo: jbo$2,\n    jgo: jgo$2,\n    jmc: jmc$2,\n    jv: jv$2,\n    jw: jw$2,\n    ka: ka$2,\n    kab: kab$2,\n    kaj: kaj$2,\n    kcg: kcg$2,\n    kde: kde$2,\n    kea: kea$2,\n    kk: kk$2,\n    kkj: kkj$2,\n    kl: kl$2,\n    km: km$2,\n    kn: kn$2,\n    ko: ko$2,\n    ks: ks$2,\n    ksb: ksb$2,\n    ksh: ksh$2,\n    ku: ku$2,\n    kw: kw$2,\n    ky: ky$2,\n    lag: lag$2,\n    lb: lb$2,\n    lg: lg$2,\n    lij: lij$2,\n    lkt: lkt$2,\n    ln: ln$2,\n    lo: lo$2,\n    lt: lt$2,\n    lv: lv$2,\n    mas: mas$2,\n    mg: mg$2,\n    mgo: mgo$2,\n    mk: mk$2,\n    ml: ml$2,\n    mn: mn$2,\n    mo: mo$2,\n    mr: mr$2,\n    ms: ms$2,\n    mt: mt$2,\n    my: my$2,\n    nah: nah$2,\n    naq: naq$2,\n    nb: nb$2,\n    nd: nd$2,\n    ne: ne$2,\n    nl: nl$2,\n    nn: nn$2,\n    nnh: nnh$2,\n    no: no$2,\n    nqo: nqo$2,\n    nr: nr$2,\n    nso: nso$2,\n    ny: ny$2,\n    nyn: nyn$2,\n    om: om$2,\n    or: or$2,\n    os: os$2,\n    osa: osa$2,\n    pa: pa$2,\n    pap: pap$2,\n    pcm: pcm$2,\n    pl: pl$2,\n    prg: prg$2,\n    ps: ps$2,\n    pt: pt$2,\n    pt_PT: pt_PT$2,\n    rm: rm$2,\n    ro: ro$2,\n    rof: rof$2,\n    ru: ru$2,\n    rwk: rwk$2,\n    sah: sah$2,\n    saq: saq$2,\n    sat: sat$2,\n    sc: sc$2,\n    scn: scn$2,\n    sd: sd$2,\n    sdh: sdh$2,\n    se: se$2,\n    seh: seh$2,\n    ses: ses$2,\n    sg: sg$2,\n    sh: sh$2,\n    shi: shi$2,\n    si: si$2,\n    sk: sk$2,\n    sl: sl$2,\n    sma: sma$2,\n    smi: smi$2,\n    smj: smj$2,\n    smn: smn$2,\n    sms: sms$2,\n    sn: sn$2,\n    so: so$2,\n    sq: sq$2,\n    sr: sr$2,\n    ss: ss$2,\n    ssy: ssy$2,\n    st: st$2,\n    su: su$2,\n    sv: sv$2,\n    sw: sw$2,\n    syr: syr$2,\n    ta: ta$2,\n    te: te$2,\n    teo: teo$2,\n    th: th$2,\n    ti: ti$2,\n    tig: tig$2,\n    tk: tk$2,\n    tl: tl$2,\n    tn: tn$2,\n    to: to$2,\n    tpi: tpi$2,\n    tr: tr$2,\n    ts: ts$2,\n    tzm: tzm$2,\n    ug: ug$2,\n    uk: uk$2,\n    und: und$2,\n    ur: ur$2,\n    uz: uz$2,\n    ve: ve$2,\n    vi: vi$2,\n    vo: vo$2,\n    vun: vun$2,\n    wa: wa$2,\n    wae: wae$2,\n    wo: wo$2,\n    xh: xh$2,\n    xog: xog$2,\n    yi: yi$2,\n    yo: yo$2,\n    yue: yue$2,\n    zh: zh$2,\n    zu: zu$2\n  });\n  var z = \"zero\",\n    o = \"one\",\n    t = \"two\",\n    f$1 = \"few\",\n    m = \"many\",\n    x = \"other\";\n  var a$1 = {\n    cardinal: [o, x],\n    ordinal: [x]\n  };\n  var b$1 = {\n    cardinal: [o, x],\n    ordinal: [o, x]\n  };\n  var c$1 = {\n    cardinal: [x],\n    ordinal: [x]\n  };\n  var d$1 = {\n    cardinal: [o, f$1, m, x],\n    ordinal: [x]\n  };\n  var e$1 = {\n    cardinal: [o, t, x],\n    ordinal: [x]\n  };\n  var af$1 = a$1;\n  var ak$1 = a$1;\n  var am$1 = a$1;\n  var an$1 = a$1;\n  var ar$1 = {\n    cardinal: [z, o, t, f$1, m, x],\n    ordinal: [x]\n  };\n  var ars$1 = {\n    cardinal: [z, o, t, f$1, m, x],\n    ordinal: [x]\n  };\n  var as$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, f$1, m, x]\n  };\n  var asa$1 = a$1;\n  var ast$1 = a$1;\n  var az$1 = {\n    cardinal: [o, x],\n    ordinal: [o, f$1, m, x]\n  };\n  var bal$1 = b$1;\n  var be$1 = {\n    cardinal: [o, f$1, m, x],\n    ordinal: [f$1, x]\n  };\n  var bem$1 = a$1;\n  var bez$1 = a$1;\n  var bg$1 = a$1;\n  var bho$1 = a$1;\n  var bm$1 = c$1;\n  var bn$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, f$1, m, x]\n  };\n  var bo$1 = c$1;\n  var br$1 = {\n    cardinal: [o, t, f$1, m, x],\n    ordinal: [x]\n  };\n  var brx$1 = a$1;\n  var bs$1 = {\n    cardinal: [o, f$1, x],\n    ordinal: [x]\n  };\n  var ca$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, f$1, x]\n  };\n  var ce$1 = a$1;\n  var ceb$1 = a$1;\n  var cgg$1 = a$1;\n  var chr$1 = a$1;\n  var ckb$1 = a$1;\n  var cs$1 = d$1;\n  var cy$1 = {\n    cardinal: [z, o, t, f$1, m, x],\n    ordinal: [z, o, t, f$1, m, x]\n  };\n  var da$1 = a$1;\n  var de$1 = a$1;\n  var doi$1 = a$1;\n  var dsb$1 = {\n    cardinal: [o, t, f$1, x],\n    ordinal: [x]\n  };\n  var dv$1 = a$1;\n  var dz$1 = c$1;\n  var ee$1 = a$1;\n  var el$1 = a$1;\n  var en$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, f$1, x]\n  };\n  var eo$1 = a$1;\n  var es$1 = {\n    cardinal: [o, m, x],\n    ordinal: [x]\n  };\n  var et$1 = a$1;\n  var eu$1 = a$1;\n  var fa$1 = a$1;\n  var ff$1 = a$1;\n  var fi$1 = a$1;\n  var fil$1 = b$1;\n  var fo$1 = a$1;\n  var fr$1 = {\n    cardinal: [o, m, x],\n    ordinal: [o, x]\n  };\n  var fur$1 = a$1;\n  var fy$1 = a$1;\n  var ga$1 = {\n    cardinal: [o, t, f$1, m, x],\n    ordinal: [o, x]\n  };\n  var gd$1 = {\n    cardinal: [o, t, f$1, x],\n    ordinal: [o, t, f$1, x]\n  };\n  var gl$1 = a$1;\n  var gsw$1 = a$1;\n  var gu$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, f$1, m, x]\n  };\n  var guw$1 = a$1;\n  var gv$1 = {\n    cardinal: [o, t, f$1, m, x],\n    ordinal: [x]\n  };\n  var ha$1 = a$1;\n  var haw$1 = a$1;\n  var he$1 = {\n    cardinal: [o, t, m, x],\n    ordinal: [x]\n  };\n  var hi$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, f$1, m, x]\n  };\n  var hnj$1 = c$1;\n  var hr$1 = {\n    cardinal: [o, f$1, x],\n    ordinal: [x]\n  };\n  var hsb$1 = {\n    cardinal: [o, t, f$1, x],\n    ordinal: [x]\n  };\n  var hu$1 = b$1;\n  var hy$1 = b$1;\n  var ia$1 = a$1;\n  var id$1 = c$1;\n  var ig$1 = c$1;\n  var ii$1 = c$1;\n  var io$1 = a$1;\n  var is$1 = a$1;\n  var it$1 = {\n    cardinal: [o, m, x],\n    ordinal: [m, x]\n  };\n  var iu$1 = e$1;\n  var ja$1 = c$1;\n  var jbo$1 = c$1;\n  var jgo$1 = a$1;\n  var jmc$1 = a$1;\n  var jv$1 = c$1;\n  var jw$1 = c$1;\n  var ka$1 = {\n    cardinal: [o, x],\n    ordinal: [o, m, x]\n  };\n  var kab$1 = a$1;\n  var kaj$1 = a$1;\n  var kcg$1 = a$1;\n  var kde$1 = c$1;\n  var kea$1 = c$1;\n  var kk$1 = {\n    cardinal: [o, x],\n    ordinal: [m, x]\n  };\n  var kkj$1 = a$1;\n  var kl$1 = a$1;\n  var km$1 = c$1;\n  var kn$1 = a$1;\n  var ko$1 = c$1;\n  var ks$1 = a$1;\n  var ksb$1 = a$1;\n  var ksh$1 = {\n    cardinal: [z, o, x],\n    ordinal: [x]\n  };\n  var ku$1 = a$1;\n  var kw$1 = {\n    cardinal: [z, o, t, f$1, m, x],\n    ordinal: [o, m, x]\n  };\n  var ky$1 = a$1;\n  var lag$1 = {\n    cardinal: [z, o, x],\n    ordinal: [x]\n  };\n  var lb$1 = a$1;\n  var lg$1 = a$1;\n  var lij$1 = {\n    cardinal: [o, x],\n    ordinal: [m, x]\n  };\n  var lkt$1 = c$1;\n  var ln$1 = a$1;\n  var lo$1 = {\n    cardinal: [x],\n    ordinal: [o, x]\n  };\n  var lt$1 = d$1;\n  var lv$1 = {\n    cardinal: [z, o, x],\n    ordinal: [x]\n  };\n  var mas$1 = a$1;\n  var mg$1 = a$1;\n  var mgo$1 = a$1;\n  var mk$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, m, x]\n  };\n  var ml$1 = a$1;\n  var mn$1 = a$1;\n  var mo$1 = {\n    cardinal: [o, f$1, x],\n    ordinal: [o, x]\n  };\n  var mr$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, f$1, x]\n  };\n  var ms$1 = {\n    cardinal: [x],\n    ordinal: [o, x]\n  };\n  var mt$1 = d$1;\n  var my$1 = c$1;\n  var nah$1 = a$1;\n  var naq$1 = e$1;\n  var nb$1 = a$1;\n  var nd$1 = a$1;\n  var ne$1 = b$1;\n  var nl$1 = a$1;\n  var nn$1 = a$1;\n  var nnh$1 = a$1;\n  var no$1 = a$1;\n  var nqo$1 = c$1;\n  var nr$1 = a$1;\n  var nso$1 = a$1;\n  var ny$1 = a$1;\n  var nyn$1 = a$1;\n  var om$1 = a$1;\n  var or$1 = {\n    cardinal: [o, x],\n    ordinal: [o, t, f$1, m, x]\n  };\n  var os$1 = a$1;\n  var osa$1 = c$1;\n  var pa$1 = a$1;\n  var pap$1 = a$1;\n  var pcm$1 = a$1;\n  var pl$1 = d$1;\n  var prg$1 = {\n    cardinal: [z, o, x],\n    ordinal: [x]\n  };\n  var ps$1 = a$1;\n  var pt$1 = {\n    cardinal: [o, m, x],\n    ordinal: [x]\n  };\n  var pt_PT$1 = {\n    cardinal: [o, m, x],\n    ordinal: [x]\n  };\n  var rm$1 = a$1;\n  var ro$1 = {\n    cardinal: [o, f$1, x],\n    ordinal: [o, x]\n  };\n  var rof$1 = a$1;\n  var ru$1 = d$1;\n  var rwk$1 = a$1;\n  var sah$1 = c$1;\n  var saq$1 = a$1;\n  var sat$1 = e$1;\n  var sc$1 = {\n    cardinal: [o, x],\n    ordinal: [m, x]\n  };\n  var scn$1 = {\n    cardinal: [o, x],\n    ordinal: [m, x]\n  };\n  var sd$1 = a$1;\n  var sdh$1 = a$1;\n  var se$1 = e$1;\n  var seh$1 = a$1;\n  var ses$1 = c$1;\n  var sg$1 = c$1;\n  var sh$1 = {\n    cardinal: [o, f$1, x],\n    ordinal: [x]\n  };\n  var shi$1 = {\n    cardinal: [o, f$1, x],\n    ordinal: [x]\n  };\n  var si$1 = a$1;\n  var sk$1 = d$1;\n  var sl$1 = {\n    cardinal: [o, t, f$1, x],\n    ordinal: [x]\n  };\n  var sma$1 = e$1;\n  var smi$1 = e$1;\n  var smj$1 = e$1;\n  var smn$1 = e$1;\n  var sms$1 = e$1;\n  var sn$1 = a$1;\n  var so$1 = a$1;\n  var sq$1 = {\n    cardinal: [o, x],\n    ordinal: [o, m, x]\n  };\n  var sr$1 = {\n    cardinal: [o, f$1, x],\n    ordinal: [x]\n  };\n  var ss$1 = a$1;\n  var ssy$1 = a$1;\n  var st$1 = a$1;\n  var su$1 = c$1;\n  var sv$1 = b$1;\n  var sw$1 = a$1;\n  var syr$1 = a$1;\n  var ta$1 = a$1;\n  var te$1 = a$1;\n  var teo$1 = a$1;\n  var th$1 = c$1;\n  var ti$1 = a$1;\n  var tig$1 = a$1;\n  var tk$1 = {\n    cardinal: [o, x],\n    ordinal: [f$1, x]\n  };\n  var tl$1 = b$1;\n  var tn$1 = a$1;\n  var to$1 = c$1;\n  var tpi$1 = c$1;\n  var tr$1 = a$1;\n  var ts$1 = a$1;\n  var tzm$1 = a$1;\n  var ug$1 = a$1;\n  var uk$1 = {\n    cardinal: [o, f$1, m, x],\n    ordinal: [f$1, x]\n  };\n  var und$1 = c$1;\n  var ur$1 = a$1;\n  var uz$1 = a$1;\n  var ve$1 = a$1;\n  var vi$1 = {\n    cardinal: [x],\n    ordinal: [o, x]\n  };\n  var vo$1 = a$1;\n  var vun$1 = a$1;\n  var wa$1 = a$1;\n  var wae$1 = a$1;\n  var wo$1 = c$1;\n  var xh$1 = a$1;\n  var xog$1 = a$1;\n  var yi$1 = a$1;\n  var yo$1 = c$1;\n  var yue$1 = c$1;\n  var zh$1 = c$1;\n  var zu$1 = a$1;\n  var PluralCategories = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    af: af$1,\n    ak: ak$1,\n    am: am$1,\n    an: an$1,\n    ar: ar$1,\n    ars: ars$1,\n    as: as$1,\n    asa: asa$1,\n    ast: ast$1,\n    az: az$1,\n    bal: bal$1,\n    be: be$1,\n    bem: bem$1,\n    bez: bez$1,\n    bg: bg$1,\n    bho: bho$1,\n    bm: bm$1,\n    bn: bn$1,\n    bo: bo$1,\n    br: br$1,\n    brx: brx$1,\n    bs: bs$1,\n    ca: ca$1,\n    ce: ce$1,\n    ceb: ceb$1,\n    cgg: cgg$1,\n    chr: chr$1,\n    ckb: ckb$1,\n    cs: cs$1,\n    cy: cy$1,\n    da: da$1,\n    de: de$1,\n    doi: doi$1,\n    dsb: dsb$1,\n    dv: dv$1,\n    dz: dz$1,\n    ee: ee$1,\n    el: el$1,\n    en: en$1,\n    eo: eo$1,\n    es: es$1,\n    et: et$1,\n    eu: eu$1,\n    fa: fa$1,\n    ff: ff$1,\n    fi: fi$1,\n    fil: fil$1,\n    fo: fo$1,\n    fr: fr$1,\n    fur: fur$1,\n    fy: fy$1,\n    ga: ga$1,\n    gd: gd$1,\n    gl: gl$1,\n    gsw: gsw$1,\n    gu: gu$1,\n    guw: guw$1,\n    gv: gv$1,\n    ha: ha$1,\n    haw: haw$1,\n    he: he$1,\n    hi: hi$1,\n    hnj: hnj$1,\n    hr: hr$1,\n    hsb: hsb$1,\n    hu: hu$1,\n    hy: hy$1,\n    ia: ia$1,\n    id: id$1,\n    ig: ig$1,\n    ii: ii$1,\n    io: io$1,\n    is: is$1,\n    it: it$1,\n    iu: iu$1,\n    ja: ja$1,\n    jbo: jbo$1,\n    jgo: jgo$1,\n    jmc: jmc$1,\n    jv: jv$1,\n    jw: jw$1,\n    ka: ka$1,\n    kab: kab$1,\n    kaj: kaj$1,\n    kcg: kcg$1,\n    kde: kde$1,\n    kea: kea$1,\n    kk: kk$1,\n    kkj: kkj$1,\n    kl: kl$1,\n    km: km$1,\n    kn: kn$1,\n    ko: ko$1,\n    ks: ks$1,\n    ksb: ksb$1,\n    ksh: ksh$1,\n    ku: ku$1,\n    kw: kw$1,\n    ky: ky$1,\n    lag: lag$1,\n    lb: lb$1,\n    lg: lg$1,\n    lij: lij$1,\n    lkt: lkt$1,\n    ln: ln$1,\n    lo: lo$1,\n    lt: lt$1,\n    lv: lv$1,\n    mas: mas$1,\n    mg: mg$1,\n    mgo: mgo$1,\n    mk: mk$1,\n    ml: ml$1,\n    mn: mn$1,\n    mo: mo$1,\n    mr: mr$1,\n    ms: ms$1,\n    mt: mt$1,\n    my: my$1,\n    nah: nah$1,\n    naq: naq$1,\n    nb: nb$1,\n    nd: nd$1,\n    ne: ne$1,\n    nl: nl$1,\n    nn: nn$1,\n    nnh: nnh$1,\n    no: no$1,\n    nqo: nqo$1,\n    nr: nr$1,\n    nso: nso$1,\n    ny: ny$1,\n    nyn: nyn$1,\n    om: om$1,\n    or: or$1,\n    os: os$1,\n    osa: osa$1,\n    pa: pa$1,\n    pap: pap$1,\n    pcm: pcm$1,\n    pl: pl$1,\n    prg: prg$1,\n    ps: ps$1,\n    pt: pt$1,\n    pt_PT: pt_PT$1,\n    rm: rm$1,\n    ro: ro$1,\n    rof: rof$1,\n    ru: ru$1,\n    rwk: rwk$1,\n    sah: sah$1,\n    saq: saq$1,\n    sat: sat$1,\n    sc: sc$1,\n    scn: scn$1,\n    sd: sd$1,\n    sdh: sdh$1,\n    se: se$1,\n    seh: seh$1,\n    ses: ses$1,\n    sg: sg$1,\n    sh: sh$1,\n    shi: shi$1,\n    si: si$1,\n    sk: sk$1,\n    sl: sl$1,\n    sma: sma$1,\n    smi: smi$1,\n    smj: smj$1,\n    smn: smn$1,\n    sms: sms$1,\n    sn: sn$1,\n    so: so$1,\n    sq: sq$1,\n    sr: sr$1,\n    ss: ss$1,\n    ssy: ssy$1,\n    st: st$1,\n    su: su$1,\n    sv: sv$1,\n    sw: sw$1,\n    syr: syr$1,\n    ta: ta$1,\n    te: te$1,\n    teo: teo$1,\n    th: th$1,\n    ti: ti$1,\n    tig: tig$1,\n    tk: tk$1,\n    tl: tl$1,\n    tn: tn$1,\n    to: to$1,\n    tpi: tpi$1,\n    tr: tr$1,\n    ts: ts$1,\n    tzm: tzm$1,\n    ug: ug$1,\n    uk: uk$1,\n    und: und$1,\n    ur: ur$1,\n    uz: uz$1,\n    ve: ve$1,\n    vi: vi$1,\n    vo: vo$1,\n    vun: vun$1,\n    wa: wa$1,\n    wae: wae$1,\n    wo: wo$1,\n    xh: xh$1,\n    xog: xog$1,\n    yi: yi$1,\n    yo: yo$1,\n    yue: yue$1,\n    zh: zh$1,\n    zu: zu$1\n  });\n  var a = function a(n, ord) {\n    if (ord) return 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var b = function b(n, ord) {\n    if (ord) return 'other';\n    return n == 0 || n == 1 ? 'one' : 'other';\n  };\n  var c = function c(n, ord) {\n    if (ord) return 'other';\n    return n >= 0 && n <= 1 ? 'one' : 'other';\n  };\n  var d = function d(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1];\n    if (ord) return 'other';\n    return n == 1 && v0 ? 'one' : 'other';\n  };\n  var e = function e(n, ord) {\n    return 'other';\n  };\n  var f = function f(n, ord) {\n    if (ord) return 'other';\n    return n == 1 ? 'one' : n == 2 ? 'two' : 'other';\n  };\n  var af = a;\n  var ak = b;\n  var am = c;\n  var an = a;\n  var ar = function ar(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return 'other';\n    return n == 0 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n100 >= 3 && n100 <= 10 ? 'few' : n100 >= 11 && n100 <= 99 ? 'many' : 'other';\n  };\n  var ars = function ars(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return 'other';\n    return n == 0 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n100 >= 3 && n100 <= 10 ? 'few' : n100 >= 11 && n100 <= 99 ? 'many' : 'other';\n  };\n  var as = function as(n, ord) {\n    if (ord) return n == 1 || n == 5 || n == 7 || n == 8 || n == 9 || n == 10 ? 'one' : n == 2 || n == 3 ? 'two' : n == 4 ? 'few' : n == 6 ? 'many' : 'other';\n    return n >= 0 && n <= 1 ? 'one' : 'other';\n  };\n  var asa = a;\n  var ast = d;\n  var az = function az(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      i1000 = i.slice(-3);\n    if (ord) return i10 == 1 || i10 == 2 || i10 == 5 || i10 == 7 || i10 == 8 || i100 == 20 || i100 == 50 || i100 == 70 || i100 == 80 ? 'one' : i10 == 3 || i10 == 4 || i1000 == 100 || i1000 == 200 || i1000 == 300 || i1000 == 400 || i1000 == 500 || i1000 == 600 || i1000 == 700 || i1000 == 800 || i1000 == 900 ? 'few' : i == 0 || i10 == 6 || i100 == 40 || i100 == 60 || i100 == 90 ? 'many' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var bal = function bal(n, ord) {\n    return n == 1 ? 'one' : 'other';\n  };\n  var be = function be(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return (n10 == 2 || n10 == 3) && n100 != 12 && n100 != 13 ? 'few' : 'other';\n    return n10 == 1 && n100 != 11 ? 'one' : n10 >= 2 && n10 <= 4 && (n100 < 12 || n100 > 14) ? 'few' : t0 && n10 == 0 || n10 >= 5 && n10 <= 9 || n100 >= 11 && n100 <= 14 ? 'many' : 'other';\n  };\n  var bem = a;\n  var bez = a;\n  var bg = a;\n  var bho = b;\n  var bm = e;\n  var bn = function bn(n, ord) {\n    if (ord) return n == 1 || n == 5 || n == 7 || n == 8 || n == 9 || n == 10 ? 'one' : n == 2 || n == 3 ? 'two' : n == 4 ? 'few' : n == 6 ? 'many' : 'other';\n    return n >= 0 && n <= 1 ? 'one' : 'other';\n  };\n  var bo = e;\n  var br = function br(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2),\n      n1000000 = t0 && s[0].slice(-6);\n    if (ord) return 'other';\n    return n10 == 1 && n100 != 11 && n100 != 71 && n100 != 91 ? 'one' : n10 == 2 && n100 != 12 && n100 != 72 && n100 != 92 ? 'two' : (n10 == 3 || n10 == 4 || n10 == 9) && (n100 < 10 || n100 > 19) && (n100 < 70 || n100 > 79) && (n100 < 90 || n100 > 99) ? 'few' : n != 0 && t0 && n1000000 == 0 ? 'many' : 'other';\n  };\n  var brx = a;\n  var bs = function bs(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    if (ord) return 'other';\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';\n  };\n  var ca = function ca(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1];\n    if (ord) return n == 1 || n == 3 ? 'one' : n == 2 ? 'two' : n == 4 ? 'few' : 'other';\n    return n == 1 && v0 ? 'one' : 'other';\n  };\n  var ce = a;\n  var ceb = function ceb(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      f10 = f.slice(-1);\n    if (ord) return 'other';\n    return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? 'one' : 'other';\n  };\n  var cgg = a;\n  var chr = a;\n  var ckb = a;\n  var cs = function cs(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1];\n    if (ord) return 'other';\n    return n == 1 && v0 ? 'one' : i >= 2 && i <= 4 && v0 ? 'few' : !v0 ? 'many' : 'other';\n  };\n  var cy = function cy(n, ord) {\n    if (ord) return n == 0 || n == 7 || n == 8 || n == 9 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n == 3 || n == 4 ? 'few' : n == 5 || n == 6 ? 'many' : 'other';\n    return n == 0 ? 'zero' : n == 1 ? 'one' : n == 2 ? 'two' : n == 3 ? 'few' : n == 6 ? 'many' : 'other';\n  };\n  var da = function da(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      t0 = Number(s[0]) == n;\n    if (ord) return 'other';\n    return n == 1 || !t0 && (i == 0 || i == 1) ? 'one' : 'other';\n  };\n  var de = d;\n  var doi = c;\n  var dsb = function dsb(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i100 = i.slice(-2),\n      f100 = f.slice(-2);\n    if (ord) return 'other';\n    return v0 && i100 == 1 || f100 == 1 ? 'one' : v0 && i100 == 2 || f100 == 2 ? 'two' : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? 'few' : 'other';\n  };\n  var dv = a;\n  var dz = e;\n  var ee = a;\n  var el = a;\n  var en = function en(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return n10 == 1 && n100 != 11 ? 'one' : n10 == 2 && n100 != 12 ? 'two' : n10 == 3 && n100 != 13 ? 'few' : 'other';\n    return n == 1 && v0 ? 'one' : 'other';\n  };\n  var eo = a;\n  var es = function es(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    if (ord) return 'other';\n    return n == 1 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var et = d;\n  var eu = a;\n  var fa = c;\n  var ff = function ff(n, ord) {\n    if (ord) return 'other';\n    return n >= 0 && n < 2 ? 'one' : 'other';\n  };\n  var fi = d;\n  var fil = function fil(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      f10 = f.slice(-1);\n    if (ord) return n == 1 ? 'one' : 'other';\n    return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? 'one' : 'other';\n  };\n  var fo = a;\n  var fr = function fr(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    if (ord) return n == 1 ? 'one' : 'other';\n    return n >= 0 && n < 2 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var fur = a;\n  var fy = d;\n  var ga = function ga(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    if (ord) return n == 1 ? 'one' : 'other';\n    return n == 1 ? 'one' : n == 2 ? 'two' : t0 && n >= 3 && n <= 6 ? 'few' : t0 && n >= 7 && n <= 10 ? 'many' : 'other';\n  };\n  var gd = function gd(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    if (ord) return n == 1 || n == 11 ? 'one' : n == 2 || n == 12 ? 'two' : n == 3 || n == 13 ? 'few' : 'other';\n    return n == 1 || n == 11 ? 'one' : n == 2 || n == 12 ? 'two' : t0 && n >= 3 && n <= 10 || t0 && n >= 13 && n <= 19 ? 'few' : 'other';\n  };\n  var gl = d;\n  var gsw = a;\n  var gu = function gu(n, ord) {\n    if (ord) return n == 1 ? 'one' : n == 2 || n == 3 ? 'two' : n == 4 ? 'few' : n == 6 ? 'many' : 'other';\n    return n >= 0 && n <= 1 ? 'one' : 'other';\n  };\n  var guw = b;\n  var gv = function gv(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    if (ord) return 'other';\n    return v0 && i10 == 1 ? 'one' : v0 && i10 == 2 ? 'two' : v0 && (i100 == 0 || i100 == 20 || i100 == 40 || i100 == 60 || i100 == 80) ? 'few' : !v0 ? 'many' : 'other';\n  };\n  var ha = a;\n  var haw = a;\n  var he = function he(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1);\n    if (ord) return 'other';\n    return n == 1 && v0 ? 'one' : i == 2 && v0 ? 'two' : v0 && (n < 0 || n > 10) && t0 && n10 == 0 ? 'many' : 'other';\n  };\n  var hi = function hi(n, ord) {\n    if (ord) return n == 1 ? 'one' : n == 2 || n == 3 ? 'two' : n == 4 ? 'few' : n == 6 ? 'many' : 'other';\n    return n >= 0 && n <= 1 ? 'one' : 'other';\n  };\n  var hnj = e;\n  var hr = function hr(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    if (ord) return 'other';\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';\n  };\n  var hsb = function hsb(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i100 = i.slice(-2),\n      f100 = f.slice(-2);\n    if (ord) return 'other';\n    return v0 && i100 == 1 || f100 == 1 ? 'one' : v0 && i100 == 2 || f100 == 2 ? 'two' : v0 && (i100 == 3 || i100 == 4) || f100 == 3 || f100 == 4 ? 'few' : 'other';\n  };\n  var hu = function hu(n, ord) {\n    if (ord) return n == 1 || n == 5 ? 'one' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var hy = function hy(n, ord) {\n    if (ord) return n == 1 ? 'one' : 'other';\n    return n >= 0 && n < 2 ? 'one' : 'other';\n  };\n  var ia = d;\n  var id = e;\n  var ig = e;\n  var ii = e;\n  var io = d;\n  var is = function is(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      t0 = Number(s[0]) == n,\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    if (ord) return 'other';\n    return t0 && i10 == 1 && i100 != 11 || !t0 ? 'one' : 'other';\n  };\n  var it = function it(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    if (ord) return n == 11 || n == 8 || n == 80 || n == 800 ? 'many' : 'other';\n    return n == 1 && v0 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var iu = f;\n  var ja = e;\n  var jbo = e;\n  var jgo = a;\n  var jmc = a;\n  var jv = e;\n  var jw = e;\n  var ka = function ka(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      i100 = i.slice(-2);\n    if (ord) return i == 1 ? 'one' : i == 0 || i100 >= 2 && i100 <= 20 || i100 == 40 || i100 == 60 || i100 == 80 ? 'many' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var kab = function kab(n, ord) {\n    if (ord) return 'other';\n    return n >= 0 && n < 2 ? 'one' : 'other';\n  };\n  var kaj = a;\n  var kcg = a;\n  var kde = e;\n  var kea = e;\n  var kk = function kk(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1);\n    if (ord) return n10 == 6 || n10 == 9 || t0 && n10 == 0 && n != 0 ? 'many' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var kkj = a;\n  var kl = a;\n  var km = e;\n  var kn = c;\n  var ko = e;\n  var ks = a;\n  var ksb = a;\n  var ksh = function ksh(n, ord) {\n    if (ord) return 'other';\n    return n == 0 ? 'zero' : n == 1 ? 'one' : 'other';\n  };\n  var ku = a;\n  var kw = function kw(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2),\n      n1000 = t0 && s[0].slice(-3),\n      n100000 = t0 && s[0].slice(-5),\n      n1000000 = t0 && s[0].slice(-6);\n    if (ord) return t0 && n >= 1 && n <= 4 || n100 >= 1 && n100 <= 4 || n100 >= 21 && n100 <= 24 || n100 >= 41 && n100 <= 44 || n100 >= 61 && n100 <= 64 || n100 >= 81 && n100 <= 84 ? 'one' : n == 5 || n100 == 5 ? 'many' : 'other';\n    return n == 0 ? 'zero' : n == 1 ? 'one' : n100 == 2 || n100 == 22 || n100 == 42 || n100 == 62 || n100 == 82 || t0 && n1000 == 0 && (n100000 >= 1000 && n100000 <= 20000 || n100000 == 40000 || n100000 == 60000 || n100000 == 80000) || n != 0 && n1000000 == 100000 ? 'two' : n100 == 3 || n100 == 23 || n100 == 43 || n100 == 63 || n100 == 83 ? 'few' : n != 1 && (n100 == 1 || n100 == 21 || n100 == 41 || n100 == 61 || n100 == 81) ? 'many' : 'other';\n  };\n  var ky = a;\n  var lag = function lag(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0];\n    if (ord) return 'other';\n    return n == 0 ? 'zero' : (i == 0 || i == 1) && n != 0 ? 'one' : 'other';\n  };\n  var lb = a;\n  var lg = a;\n  var lij = function lij(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1],\n      t0 = Number(s[0]) == n;\n    if (ord) return n == 11 || n == 8 || t0 && n >= 80 && n <= 89 || t0 && n >= 800 && n <= 899 ? 'many' : 'other';\n    return n == 1 && v0 ? 'one' : 'other';\n  };\n  var lkt = e;\n  var ln = b;\n  var lo = function lo(n, ord) {\n    if (ord) return n == 1 ? 'one' : 'other';\n    return 'other';\n  };\n  var lt = function lt(n, ord) {\n    var s = String(n).split('.'),\n      f = s[1] || '',\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return 'other';\n    return n10 == 1 && (n100 < 11 || n100 > 19) ? 'one' : n10 >= 2 && n10 <= 9 && (n100 < 11 || n100 > 19) ? 'few' : f != 0 ? 'many' : 'other';\n  };\n  var lv = function lv(n, ord) {\n    var s = String(n).split('.'),\n      f = s[1] || '',\n      v = f.length,\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2),\n      f100 = f.slice(-2),\n      f10 = f.slice(-1);\n    if (ord) return 'other';\n    return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? 'zero' : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? 'one' : 'other';\n  };\n  var mas = a;\n  var mg = b;\n  var mgo = a;\n  var mk = function mk(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    if (ord) return i10 == 1 && i100 != 11 ? 'one' : i10 == 2 && i100 != 12 ? 'two' : (i10 == 7 || i10 == 8) && i100 != 17 && i100 != 18 ? 'many' : 'other';\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : 'other';\n  };\n  var ml = a;\n  var mn = a;\n  var mo = function mo(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return n == 1 ? 'one' : 'other';\n    return n == 1 && v0 ? 'one' : !v0 || n == 0 || n100 >= 2 && n100 <= 19 ? 'few' : 'other';\n  };\n  var mr = function mr(n, ord) {\n    if (ord) return n == 1 ? 'one' : n == 2 || n == 3 ? 'two' : n == 4 ? 'few' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var ms = function ms(n, ord) {\n    if (ord) return n == 1 ? 'one' : 'other';\n    return 'other';\n  };\n  var mt = function mt(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return 'other';\n    return n == 1 ? 'one' : n == 0 || n100 >= 2 && n100 <= 10 ? 'few' : n100 >= 11 && n100 <= 19 ? 'many' : 'other';\n  };\n  var my = e;\n  var nah = a;\n  var naq = f;\n  var nb = a;\n  var nd = a;\n  var ne = function ne(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    if (ord) return t0 && n >= 1 && n <= 4 ? 'one' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var nl = d;\n  var nn = a;\n  var nnh = a;\n  var no = a;\n  var nqo = e;\n  var nr = a;\n  var nso = b;\n  var ny = a;\n  var nyn = a;\n  var om = a;\n  var or = function or(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    if (ord) return n == 1 || n == 5 || t0 && n >= 7 && n <= 9 ? 'one' : n == 2 || n == 3 ? 'two' : n == 4 ? 'few' : n == 6 ? 'many' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var os = a;\n  var osa = e;\n  var pa = b;\n  var pap = a;\n  var pcm = c;\n  var pl = function pl(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    if (ord) return 'other';\n    return n == 1 && v0 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? 'few' : v0 && i != 1 && (i10 == 0 || i10 == 1) || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 12 && i100 <= 14 ? 'many' : 'other';\n  };\n  var prg = function prg(n, ord) {\n    var s = String(n).split('.'),\n      f = s[1] || '',\n      v = f.length,\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2),\n      f100 = f.slice(-2),\n      f10 = f.slice(-1);\n    if (ord) return 'other';\n    return t0 && n10 == 0 || n100 >= 11 && n100 <= 19 || v == 2 && f100 >= 11 && f100 <= 19 ? 'zero' : n10 == 1 && n100 != 11 || v == 2 && f10 == 1 && f100 != 11 || v != 2 && f10 == 1 ? 'one' : 'other';\n  };\n  var ps = a;\n  var pt = function pt(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    if (ord) return 'other';\n    return i == 0 || i == 1 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var pt_PT = function pt_PT(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i1000000 = i.slice(-6);\n    if (ord) return 'other';\n    return n == 1 && v0 ? 'one' : i != 0 && i1000000 == 0 && v0 ? 'many' : 'other';\n  };\n  var rm = a;\n  var ro = function ro(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return n == 1 ? 'one' : 'other';\n    return n == 1 && v0 ? 'one' : !v0 || n == 0 || n100 >= 2 && n100 <= 19 ? 'few' : 'other';\n  };\n  var rof = a;\n  var ru = function ru(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    if (ord) return 'other';\n    return v0 && i10 == 1 && i100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? 'few' : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? 'many' : 'other';\n  };\n  var rwk = a;\n  var sah = e;\n  var saq = a;\n  var sat = f;\n  var sc = function sc(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1];\n    if (ord) return n == 11 || n == 8 || n == 80 || n == 800 ? 'many' : 'other';\n    return n == 1 && v0 ? 'one' : 'other';\n  };\n  var scn = function scn(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1];\n    if (ord) return n == 11 || n == 8 || n == 80 || n == 800 ? 'many' : 'other';\n    return n == 1 && v0 ? 'one' : 'other';\n  };\n  var sd = a;\n  var sdh = a;\n  var se = f;\n  var seh = a;\n  var ses = e;\n  var sg = e;\n  var sh = function sh(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    if (ord) return 'other';\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';\n  };\n  var shi = function shi(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    if (ord) return 'other';\n    return n >= 0 && n <= 1 ? 'one' : t0 && n >= 2 && n <= 10 ? 'few' : 'other';\n  };\n  var si = function si(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '';\n    if (ord) return 'other';\n    return n == 0 || n == 1 || i == 0 && f == 1 ? 'one' : 'other';\n  };\n  var sk = function sk(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1];\n    if (ord) return 'other';\n    return n == 1 && v0 ? 'one' : i >= 2 && i <= 4 && v0 ? 'few' : !v0 ? 'many' : 'other';\n  };\n  var sl = function sl(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      i100 = i.slice(-2);\n    if (ord) return 'other';\n    return v0 && i100 == 1 ? 'one' : v0 && i100 == 2 ? 'two' : v0 && (i100 == 3 || i100 == 4) || !v0 ? 'few' : 'other';\n  };\n  var sma = f;\n  var smi = f;\n  var smj = f;\n  var smn = f;\n  var sms = f;\n  var sn = a;\n  var so = a;\n  var sq = function sq(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return n == 1 ? 'one' : n10 == 4 && n100 != 14 ? 'many' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var sr = function sr(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      i100 = i.slice(-2),\n      f10 = f.slice(-1),\n      f100 = f.slice(-2);\n    if (ord) return 'other';\n    return v0 && i10 == 1 && i100 != 11 || f10 == 1 && f100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) || f10 >= 2 && f10 <= 4 && (f100 < 12 || f100 > 14) ? 'few' : 'other';\n  };\n  var ss = a;\n  var ssy = a;\n  var st = a;\n  var su = e;\n  var sv = function sv(n, ord) {\n    var s = String(n).split('.'),\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2);\n    if (ord) return (n10 == 1 || n10 == 2) && n100 != 11 && n100 != 12 ? 'one' : 'other';\n    return n == 1 && v0 ? 'one' : 'other';\n  };\n  var sw = d;\n  var syr = a;\n  var ta = a;\n  var te = a;\n  var teo = a;\n  var th = e;\n  var ti = b;\n  var tig = a;\n  var tk = function tk(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1);\n    if (ord) return n10 == 6 || n10 == 9 || n == 10 ? 'few' : 'other';\n    return n == 1 ? 'one' : 'other';\n  };\n  var tl = function tl(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      f = s[1] || '',\n      v0 = !s[1],\n      i10 = i.slice(-1),\n      f10 = f.slice(-1);\n    if (ord) return n == 1 ? 'one' : 'other';\n    return v0 && (i == 1 || i == 2 || i == 3) || v0 && i10 != 4 && i10 != 6 && i10 != 9 || !v0 && f10 != 4 && f10 != 6 && f10 != 9 ? 'one' : 'other';\n  };\n  var tn = a;\n  var to = e;\n  var tpi = e;\n  var tr = a;\n  var ts = a;\n  var tzm = function tzm(n, ord) {\n    var s = String(n).split('.'),\n      t0 = Number(s[0]) == n;\n    if (ord) return 'other';\n    return n == 0 || n == 1 || t0 && n >= 11 && n <= 99 ? 'one' : 'other';\n  };\n  var ug = a;\n  var uk = function uk(n, ord) {\n    var s = String(n).split('.'),\n      i = s[0],\n      v0 = !s[1],\n      t0 = Number(s[0]) == n,\n      n10 = t0 && s[0].slice(-1),\n      n100 = t0 && s[0].slice(-2),\n      i10 = i.slice(-1),\n      i100 = i.slice(-2);\n    if (ord) return n10 == 3 && n100 != 13 ? 'few' : 'other';\n    return v0 && i10 == 1 && i100 != 11 ? 'one' : v0 && i10 >= 2 && i10 <= 4 && (i100 < 12 || i100 > 14) ? 'few' : v0 && i10 == 0 || v0 && i10 >= 5 && i10 <= 9 || v0 && i100 >= 11 && i100 <= 14 ? 'many' : 'other';\n  };\n  var und = e;\n  var ur = d;\n  var uz = a;\n  var ve = a;\n  var vi = function vi(n, ord) {\n    if (ord) return n == 1 ? 'one' : 'other';\n    return 'other';\n  };\n  var vo = a;\n  var vun = a;\n  var wa = b;\n  var wae = a;\n  var wo = e;\n  var xh = a;\n  var xog = a;\n  var yi = d;\n  var yo = e;\n  var yue = e;\n  var zh = e;\n  var zu = c;\n  var Plurals = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    af: af,\n    ak: ak,\n    am: am,\n    an: an,\n    ar: ar,\n    ars: ars,\n    as: as,\n    asa: asa,\n    ast: ast,\n    az: az,\n    bal: bal,\n    be: be,\n    bem: bem,\n    bez: bez,\n    bg: bg,\n    bho: bho,\n    bm: bm,\n    bn: bn,\n    bo: bo,\n    br: br,\n    brx: brx,\n    bs: bs,\n    ca: ca,\n    ce: ce,\n    ceb: ceb,\n    cgg: cgg,\n    chr: chr,\n    ckb: ckb,\n    cs: cs,\n    cy: cy,\n    da: da,\n    de: de,\n    doi: doi,\n    dsb: dsb,\n    dv: dv,\n    dz: dz,\n    ee: ee,\n    el: el,\n    en: en,\n    eo: eo,\n    es: es,\n    et: et,\n    eu: eu,\n    fa: fa,\n    ff: ff,\n    fi: fi,\n    fil: fil,\n    fo: fo,\n    fr: fr,\n    fur: fur,\n    fy: fy,\n    ga: ga,\n    gd: gd,\n    gl: gl,\n    gsw: gsw,\n    gu: gu,\n    guw: guw,\n    gv: gv,\n    ha: ha,\n    haw: haw,\n    he: he,\n    hi: hi,\n    hnj: hnj,\n    hr: hr,\n    hsb: hsb,\n    hu: hu,\n    hy: hy,\n    ia: ia,\n    id: id,\n    ig: ig,\n    ii: ii,\n    io: io,\n    is: is,\n    it: it,\n    iu: iu,\n    ja: ja,\n    jbo: jbo,\n    jgo: jgo,\n    jmc: jmc,\n    jv: jv,\n    jw: jw,\n    ka: ka,\n    kab: kab,\n    kaj: kaj,\n    kcg: kcg,\n    kde: kde,\n    kea: kea,\n    kk: kk,\n    kkj: kkj,\n    kl: kl,\n    km: km,\n    kn: kn,\n    ko: ko,\n    ks: ks,\n    ksb: ksb,\n    ksh: ksh,\n    ku: ku,\n    kw: kw,\n    ky: ky,\n    lag: lag,\n    lb: lb,\n    lg: lg,\n    lij: lij,\n    lkt: lkt,\n    ln: ln,\n    lo: lo,\n    lt: lt,\n    lv: lv,\n    mas: mas,\n    mg: mg,\n    mgo: mgo,\n    mk: mk,\n    ml: ml,\n    mn: mn,\n    mo: mo,\n    mr: mr,\n    ms: ms,\n    mt: mt,\n    my: my,\n    nah: nah,\n    naq: naq,\n    nb: nb,\n    nd: nd,\n    ne: ne,\n    nl: nl,\n    nn: nn,\n    nnh: nnh,\n    no: no,\n    nqo: nqo,\n    nr: nr,\n    nso: nso,\n    ny: ny,\n    nyn: nyn,\n    om: om,\n    or: or,\n    os: os,\n    osa: osa,\n    pa: pa,\n    pap: pap,\n    pcm: pcm,\n    pl: pl,\n    prg: prg,\n    ps: ps,\n    pt: pt,\n    pt_PT: pt_PT,\n    rm: rm,\n    ro: ro,\n    rof: rof,\n    ru: ru,\n    rwk: rwk,\n    sah: sah,\n    saq: saq,\n    sat: sat,\n    sc: sc,\n    scn: scn,\n    sd: sd,\n    sdh: sdh,\n    se: se,\n    seh: seh,\n    ses: ses,\n    sg: sg,\n    sh: sh,\n    shi: shi,\n    si: si,\n    sk: sk,\n    sl: sl,\n    sma: sma,\n    smi: smi,\n    smj: smj,\n    smn: smn,\n    sms: sms,\n    sn: sn,\n    so: so,\n    sq: sq,\n    sr: sr,\n    ss: ss,\n    ssy: ssy,\n    st: st,\n    su: su,\n    sv: sv,\n    sw: sw,\n    syr: syr,\n    ta: ta,\n    te: te,\n    teo: teo,\n    th: th,\n    ti: ti,\n    tig: tig,\n    tk: tk,\n    tl: tl,\n    tn: tn,\n    to: to,\n    tpi: tpi,\n    tr: tr,\n    ts: ts,\n    tzm: tzm,\n    ug: ug,\n    uk: uk,\n    und: und,\n    ur: ur,\n    uz: uz,\n    ve: ve,\n    vi: vi,\n    vo: vo,\n    vun: vun,\n    wa: wa,\n    wae: wae,\n    wo: wo,\n    xh: xh,\n    xog: xog,\n    yi: yi,\n    yo: yo,\n    yue: yue,\n    zh: zh,\n    zu: zu\n  });\n  function normalize(locale) {\n    if (typeof locale !== 'string' || locale.length < 2) throw new RangeError(\"Invalid language tag: \".concat(locale));\n    if (locale.startsWith('pt-PT')) return 'pt-PT';\n    var m = locale.match(/.+?(?=[-_])/);\n    return m ? m[0] : locale;\n  }\n  function getPlural(locale) {\n    if (typeof locale === 'function') {\n      var lc_1 = normalize(locale.name);\n      return {\n        isDefault: false,\n        id: identifier(lc_1),\n        lc: lc_1,\n        locale: locale.name,\n        getPlural: locale,\n        cardinals: locale.cardinals || [],\n        ordinals: locale.ordinals || []\n      };\n    }\n    var lc = normalize(locale);\n    var id = identifier(lc);\n    if (isPluralId(id)) {\n      return {\n        isDefault: true,\n        id: id,\n        lc: lc,\n        locale: locale,\n        getCardinal: Cardinals[id],\n        getPlural: Plurals[id],\n        cardinals: PluralCategories[id].cardinal,\n        ordinals: PluralCategories[id].ordinal\n      };\n    }\n    return null;\n  }\n  function getAllPlurals(firstLocale) {\n    var keys = Object.keys(Plurals).filter(function (key) {\n      return key !== firstLocale;\n    });\n    keys.unshift(firstLocale);\n    return keys.map(getPlural);\n  }\n  function hasPlural(locale) {\n    var lc = normalize(locale);\n    return identifier(lc) in Plurals;\n  }\n  function isPluralId(id) {\n    return id in Plurals;\n  }\n  var MessageFormat = function () {\n    function MessageFormat(locale, options) {\n      this.plurals = [];\n      this.options = Object.assign({\n        biDiSupport: false,\n        currency: 'USD',\n        customFormatters: {},\n        requireAllArguments: false,\n        returnType: 'string',\n        strict: options && options.strictNumberSign || false\n      }, options);\n      if (locale === '*') {\n        this.plurals = getAllPlurals(MessageFormat.defaultLocale);\n      } else if (Array.isArray(locale)) {\n        this.plurals = locale.map(getPlural).filter(Boolean);\n      } else if (locale) {\n        var pl = getPlural(locale);\n        if (pl) this.plurals = [pl];\n      }\n      if (this.plurals.length === 0) {\n        var pl = getPlural(MessageFormat.defaultLocale);\n        this.plurals = [pl];\n      }\n    }\n    MessageFormat.escape = function (str, octothorpe) {\n      var esc = octothorpe ? /[#{}]/g : /[{}]/g;\n      return String(str).replace(esc, \"'$&'\");\n    };\n    MessageFormat.supportedLocalesOf = function (locales) {\n      var la = Array.isArray(locales) ? locales : [locales];\n      return la.filter(hasPlural);\n    };\n    MessageFormat.prototype.resolvedOptions = function () {\n      return _assign(_assign({}, this.options), {\n        locale: this.plurals[0].locale,\n        plurals: this.plurals\n      });\n    };\n    MessageFormat.prototype.compile = function (message) {\n      var e_1, _a;\n      var compiler = new Compiler(this.options);\n      var fnBody = 'return ' + compiler.compile(message, this.plurals[0]);\n      var nfArgs = [];\n      var fnArgs = [];\n      try {\n        for (var _b = __values(Object.entries(compiler.runtime)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = __read(_c.value, 2),\n            key = _d[0],\n            fmt = _d[1];\n          nfArgs.push(key);\n          fnArgs.push(fmt);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      var fn = new (Function.bind.apply(Function, __spreadArray(__spreadArray([void 0], __read(nfArgs), false), [fnBody], false)))();\n      return fn.apply(void 0, __spreadArray([], __read(fnArgs), false));\n    };\n    MessageFormat.defaultLocale = 'en';\n    return MessageFormat;\n  }();\n  return MessageFormat;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}